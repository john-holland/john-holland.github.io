/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/tinycolor2/esm/tinycolor.js":
/*!**************************************************!*\
  !*** ./node_modules/tinycolor2/esm/tinycolor.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ tinycolor)
/* harmony export */ });
// This file is autogenerated. It's used to publish ESM to npm.
function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color, opts) {
  color = color ? color : "";
  opts = opts || {};

  // If input is already a tinycolor, return itself
  if (color instanceof tinycolor) {
    return color;
  }
  // If we are called as a function, call using new instead
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color, opts);
  }
  var rgb = inputToRGB(color);
  this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
  this._gradientType = opts.gradientType;

  // Don't let the range of [0,255] come back in [0,1].
  // Potentially lose a little bit of precision here, but will fix issues where
  // .5 gets interpreted as half of the total, instead of half of 1
  // If it was supposed to be 128, this was already taken care of by `inputToRgb`
  if (this._r < 1) this._r = Math.round(this._r);
  if (this._g < 1) this._g = Math.round(this._g);
  if (this._b < 1) this._b = Math.round(this._b);
  this._ok = rgb.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    //http://www.w3.org/TR/AERT#color-contrast
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
  },
  getLuminance: function getLuminance() {
    //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
    var rgb = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R, G, B;
    RsRGB = rgb.r / 255;
    GsRGB = rgb.g / 255;
    BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928) R = RsRGB / 12.92;else R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928) G = GsRGB / 12.92;else G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928) B = BsRGB / 12.92;else B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R + 0.7152 * G + 0.0722 * B;
  },
  setAlpha: function setAlpha(value) {
    this._a = boundAlpha(value);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h = Math.round(hsv.h * 360),
      s = Math.round(hsv.s * 100),
      v = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl.h * 360,
      s: hsl.s,
      l: hsl.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    var h = Math.round(hsl.h * 360),
      s = Math.round(hsl.s * 100),
      l = Math.round(hsl.l * 100);
    return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString(format) {
    var formatSet = !!format;
    format = format || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
    if (needsAlphaFormat) {
      // Special case for "transparent", all other non-alpha formats
      // will return rgba when there is transparency.
      if (format === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format === "hex" || format === "hex6") {
      formattedString = this.toHexString();
    }
    if (format === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format === "name") {
      formattedString = this.toName();
    }
    if (format === "hsl") {
      formattedString = this.toHslString();
    }
    if (format === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn, args) {
    var color = fn.apply(null, [this].concat([].slice.call(args)));
    this._r = color._r;
    this._g = color._g;
    this._b = color._b;
    this.setAlpha(color._a);
    return this;
  },
  lighten: function lighten() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn, args) {
    return fn.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};

// If input is an object, force 1 into "1.0" to handle ratios properly
// String input requires "1.0" as input, so 1 will be treated as 1
tinycolor.fromRatio = function (color, opts) {
  if (_typeof(color) == "object") {
    var newColor = {};
    for (var i in color) {
      if (color.hasOwnProperty(i)) {
        if (i === "a") {
          newColor[i] = color[i];
        } else {
          newColor[i] = convertToPercentage(color[i]);
        }
      }
    }
    color = newColor;
  }
  return tinycolor(color, opts);
};

// Given a string or object, convert that input to RGB
// Possible string inputs:
//
//     "red"
//     "#f00" or "f00"
//     "#ff0000" or "ff0000"
//     "#ff000000" or "ff000000"
//     "rgb 255 0 0" or "rgb (255, 0, 0)"
//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
//
function inputToRGB(color) {
  var rgb = {
    r: 0,
    g: 0,
    b: 0
  };
  var a = 1;
  var s = null;
  var v = null;
  var l = null;
  var ok = false;
  var format = false;
  if (typeof color == "string") {
    color = stringInputToObject(color);
  }
  if (_typeof(color) == "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s = convertToPercentage(color.s);
      v = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s, v);
      ok = true;
      format = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s = convertToPercentage(color.s);
      l = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s, l);
      ok = true;
      format = "hsl";
    }
    if (color.hasOwnProperty("a")) {
      a = color.a;
    }
  }
  a = boundAlpha(a);
  return {
    ok: ok,
    format: color.format || format,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a
  };
}

// Conversion Functions
// --------------------

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

// `rgbToRgb`
// Handle bounds / percentage checking to conform to CSS color spec
// <http://www.w3.org/TR/css3-color/>
// *Assumes:* r, g, b in [0, 255] or [0, 1]
// *Returns:* { r, g, b } in [0, 255]
function rgbToRgb(r, g, b) {
  return {
    r: bound01(r, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}

// `rgbToHsl`
// Converts an RGB color value to HSL.
// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
// *Returns:* { h, s, l } in [0,1]
function rgbToHsl(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b),
    min = Math.min(r, g, b);
  var h,
    s,
    l = (max + min) / 2;
  if (max == min) {
    h = s = 0; // achromatic
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h: h,
    s: s,
    l: l
  };
}

// `hslToRgb`
// Converts an HSL color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hslToRgb(h, s, l) {
  var r, g, b;
  h = bound01(h, 360);
  s = bound01(s, 100);
  l = bound01(l, 100);
  function hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  }
  if (s === 0) {
    r = g = b = l; // achromatic
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
function rgbToHsv(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b),
    min = Math.min(r, g, b);
  var h,
    s,
    v = max;
  var d = max - min;
  s = max === 0 ? 0 : d / max;
  if (max == min) {
    h = 0; // achromatic
  } else {
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h: h,
    s: s,
    v: v
  };
}

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hsvToRgb(h, s, v) {
  h = bound01(h, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  var i = Math.floor(h),
    f = h - i,
    p = v * (1 - s),
    q = v * (1 - f * s),
    t = v * (1 - (1 - f) * s),
    mod = i % 6,
    r = [v, q, p, p, t, v][mod],
    g = [t, v, v, q, p, p][mod],
    b = [p, p, t, v, v, q][mod];
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}

// `rgbToHex`
// Converts an RGB color to hex
// Assumes r, g, and b are contained in the set [0, 255]
// Returns a 3 or 6 character hex
function rgbToHex(r, g, b, allow3Char) {
  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];

  // Return a 3 character hex if possible
  if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}

// `rgbaToHex`
// Converts an RGBA color plus alpha transparency to hex
// Assumes r, g, b are contained in the set [0, 255] and
// a in [0, 1]. Returns a 4 or 8 character rgba hex
function rgbaToHex(r, g, b, a, allow4Char) {
  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a))];

  // Return a 4 character hex if possible
  if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}

// `rgbaToArgbHex`
// Converts an RGBA color to an ARGB Hex8 string
// Rarely used, but required for "toFilter()"
function rgbaToArgbHex(r, g, b, a) {
  var hex = [pad2(convertDecimalToHex(a)), pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  return hex.join("");
}

// `equals`
// Can be called with any tinycolor input
tinycolor.equals = function (color1, color2) {
  if (!color1 || !color2) return false;
  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function () {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};

// Modification Functions
// ----------------------
// Thanks to less.js for some of the basics here
// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

function _desaturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s -= amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _saturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s += amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _greyscale(color) {
  return tinycolor(color).desaturate(100);
}
function _lighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l += amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _brighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb = tinycolor(color).toRgb();
  rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
  rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb);
}
function _darken(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l -= amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}

// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
// Values outside of this range will be wrapped into this range.
function _spin(color, amount) {
  var hsl = tinycolor(color).toHsl();
  var hue = (hsl.h + amount) % 360;
  hsl.h = hue < 0 ? 360 + hue : hue;
  return tinycolor(hsl);
}

// Combination Functions
// ---------------------
// Thanks to jQuery xColor for some of the ideas behind these
// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

function _complement(color) {
  var hsl = tinycolor(color).toHsl();
  hsl.h = (hsl.h + 180) % 360;
  return tinycolor(hsl);
}
function polyad(color, number) {
  if (isNaN(number) || number <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl = tinycolor(color).toHsl();
  var result = [tinycolor(color)];
  var step = 360 / number;
  for (var i = 1; i < number; i++) {
    result.push(tinycolor({
      h: (hsl.h + i * step) % 360,
      s: hsl.s,
      l: hsl.l
    }));
  }
  return result;
}
function _splitcomplement(color) {
  var hsl = tinycolor(color).toHsl();
  var h = hsl.h;
  return [tinycolor(color), tinycolor({
    h: (h + 72) % 360,
    s: hsl.s,
    l: hsl.l
  }), tinycolor({
    h: (h + 216) % 360,
    s: hsl.s,
    l: hsl.l
  })];
}
function _analogous(color, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl = tinycolor(color).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color)];
  for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;) {
    hsl.h = (hsl.h + part) % 360;
    ret.push(tinycolor(hsl));
  }
  return ret;
}
function _monochromatic(color, results) {
  results = results || 6;
  var hsv = tinycolor(color).toHsv();
  var h = hsv.h,
    s = hsv.s,
    v = hsv.v;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h: h,
      s: s,
      v: v
    }));
    v = (v + modification) % 1;
  }
  return ret;
}

// Utility Functions
// ---------------------

tinycolor.mix = function (color1, color2, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb2 = tinycolor(color2).toRgb();
  var p = amount / 100;
  var rgba = {
    r: (rgb2.r - rgb1.r) * p + rgb1.r,
    g: (rgb2.g - rgb1.g) * p + rgb1.g,
    b: (rgb2.b - rgb1.b) * p + rgb1.b,
    a: (rgb2.a - rgb1.a) * p + rgb1.a
  };
  return tinycolor(rgba);
};

// Readability Functions
// ---------------------
// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

// `contrast`
// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
tinycolor.readability = function (color1, color2) {
  var c1 = tinycolor(color1);
  var c2 = tinycolor(color2);
  return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
};

// `isReadable`
// Ensure that foreground and background color combinations meet WCAG2 guidelines.
// The third argument is an optional Object.
//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

// *Example*
//    tinycolor.isReadable("#000", "#111") => false
//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
tinycolor.isReadable = function (color1, color2, wcag2) {
  var readability = tinycolor.readability(color1, color2);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};

// `mostReadable`
// Given a base color and a list of possible foreground or background
// colors for that base, returns the most readable color.
// Optionally returns Black or White if the most readable color is unreadable.
// *Example*
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
tinycolor.mostReadable = function (baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size = args.size;
  for (var i = 0; i < colorList.length; i++) {
    readability = tinycolor.readability(baseColor, colorList[i]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level: level,
    size: size
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};

// Big List of Colors
// ------------------
// <https://www.w3.org/TR/css-color-4/#named-colors>
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};

// Make it easy to access colors via `hexNames[hex]`
var hexNames = tinycolor.hexNames = flip(names);

// Utilities
// ---------

// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
function flip(o) {
  var flipped = {};
  for (var i in o) {
    if (o.hasOwnProperty(i)) {
      flipped[o[i]] = i;
    }
  }
  return flipped;
}

// Return a valid alpha value [0,1] with all invalid values being set to 1
function boundAlpha(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
}

// Take input from [0, n] and return it as [0, 1]
function bound01(n, max) {
  if (isOnePointZero(n)) n = "100%";
  var processPercent = isPercentage(n);
  n = Math.min(max, Math.max(0, parseFloat(n)));

  // Automatically convert percentage into number
  if (processPercent) {
    n = parseInt(n * max, 10) / 100;
  }

  // Handle floating point rounding errors
  if (Math.abs(n - max) < 0.000001) {
    return 1;
  }

  // Convert into [0, 1] range if it isn't already
  return n % max / parseFloat(max);
}

// Force a number between 0 and 1
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}

// Parse a base-16 hex value into a base-10 integer
function parseIntFromHex(val) {
  return parseInt(val, 16);
}

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
function isOnePointZero(n) {
  return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
}

// Check to see if string passed in is a percentage
function isPercentage(n) {
  return typeof n === "string" && n.indexOf("%") != -1;
}

// Force a hex value to have 2 characters
function pad2(c) {
  return c.length == 1 ? "0" + c : "" + c;
}

// Replace a decimal with it's percentage value
function convertToPercentage(n) {
  if (n <= 1) {
    n = n * 100 + "%";
  }
  return n;
}

// Converts a decimal to a hex value
function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
// Converts a hex value to a decimal
function convertHexToDecimal(h) {
  return parseIntFromHex(h) / 255;
}
var matchers = function () {
  // <http://www.w3.org/TR/css3-values/#integers>
  var CSS_INTEGER = "[-\\+]?\\d+%?";

  // <http://www.w3.org/TR/css3-values/#number-value>
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

  // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

  // Actual matching.
  // Parentheses and commas are optional, but not required.
  // Whitespace can take the place of commas or opening paren
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();

// `isValidCSSUnit`
// Take in a single string / number and check to see if it looks like a CSS unit
// (see `matchers` above for definition).
function isValidCSSUnit(color) {
  return !!matchers.CSS_UNIT.exec(color);
}

// `stringInputToObject`
// Permissive string parsing.  Take in a number of formats, and output an object
// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
function stringInputToObject(color) {
  color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }

  // Try to match string input using regular expressions.
  // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
  // Just return an object and let the conversion functions handle that.
  // This way the result will be the same whether the tinycolor is initialized with string or object.
  var match;
  if (match = matchers.rgb.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }
  if (match = matchers.rgba.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsl.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }
  if (match = matchers.hsla.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsv.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }
  if (match = matchers.hsva.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hex8.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex6.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  if (match = matchers.hex4.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      a: convertHexToDecimal(match[4] + "" + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex3.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  // return valid WCAG2 parms for isReadable.
  // If input parms are invalid, return {"level":"AA", "size":"small"}
  var level, size;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size !== "small" && size !== "large") {
    size = "small";
  }
  return {
    level: level,
    size: size
  };
}




/***/ }),

/***/ "./node_modules/workboots/dist/work-boots.browser.js":
/*!***********************************************************!*\
  !*** ./node_modules/workboots/dist/work-boots.browser.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.WorkBoots = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],3:[function(require,module,exports){
(function (process,global){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WorkBoots = exports.Socks = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, "default": e }; if (null === e || "object" != _typeof(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t3 in e) "default" !== _t3 && {}.hasOwnProperty.call(e, _t3) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t3)) && (i.get || i.set) ? o(f, _t3, i) : f[_t3] = e[_t3]); return f; })(e, t); }
/**
 * Universal entry point for work-boots
 * Compatible with Browserify, Node.js, and ES modules
 */

// Detect environment
var isNode = typeof process !== 'undefined' && process.versions && process.versions.node;
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';

// Universal require/import function
function universalRequire(moduleName) {
  if (isNode) {
    // In Node.js, use dynamic import
    return function (specifier) {
      return new Promise(function (r) {
        return r("".concat(specifier));
      }).then(function (s) {
        return _interopRequireWildcard(require(s));
      });
    }(moduleName);
  } else {
    // In browser, assume it's available globally or bundled
    return Promise.resolve({
      "default": global[moduleName]
    });
  }
}

// Enhanced WorkBoots with Browserify compatibility
var WorkBoots = exports.WorkBoots = /*#__PURE__*/function () {
  function WorkBoots(_ref) {
    var _this = this;
    var socksFile = _ref.socksFile,
      _ref$instantiateWorke = _ref.instantiateWorker,
      instantiateWorker = _ref$instantiateWorke === void 0 ? null : _ref$instantiateWorke;
    _classCallCheck(this, WorkBoots);
    if (socksFile === undefined) {
      this.readyPromise = Promise.reject(new Error('no socksFile defined!'));
      return;
    }

    // Determine worker support based on environment
    this.supportsWorker = this.detectWorkerSupport();
    this.receivedBeforeReady = [];
    this.isReady = false;

    // Create default worker instantiation function based on environment
    if (!instantiateWorker) {
      instantiateWorker = this.createDefaultWorkerFactory();
    }
    this.readyPromise = new Promise(function (resolve) {
      var velcroAndLaces = function velcroAndLaces(message) {
        if ((message === null || message === void 0 ? void 0 : message.data) === 'socks loaded') {
          resolve(_this);
        } else {
          for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            rest[_key - 1] = arguments[_key];
          }
          console.log('received message before socks.ready() was called, ' + JSON.stringify([message].concat(rest)));
          _this.receivedBeforeReady.push([message].concat(rest));
        }
      };
      _this.onMessage(velcroAndLaces);
      if (_this.supportsWorker) {
        try {
          _this.worker = instantiateWorker(socksFile);
          _this.supportsWorker = true;
          _this.isReady = true;
        } catch (e) {
          _this.worker = undefined;
          _this.supportsWorker = false;
          console.log('background worker not supported, switching to shorter socks (main thread eval).', e);
        }
      }
      if (!_this.supportsWorker) {
        _this.supportsWorker = false;
        // Handle import errors gracefully with Browserify compatibility
        _this.loadSocksFile(socksFile).then(function (_ref2) {
          var socks = _ref2.socks;
          _this.socks = socks;
          _this.socks.enterBoots(_this);
          _this.isReady = true;
          resolve(_this);
        })["catch"](function (error) {
          console.log('Failed to import socks file, creating mock socks:', error.message);
          // Create a mock socks for testing
          _this.socks = {
            enterBoots: function enterBoots(boots) {
              _this.boots = boots;
            },
            onMessageLocal: function onMessageLocal(message) {
              if (_this.onMessageCallback) {
                _this.onMessageCallback({
                  data: message.data
                });
              }
            },
            terminate: function terminate() {}
          };
          _this.socks.enterBoots(_this);
          _this.isReady = true;
          resolve(_this);
        });
      }
    });
  }

  // Browserify-compatible module loading
  return _createClass(WorkBoots, [{
    key: "loadSocksFile",
    value: function () {
      var _loadSocksFile = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(socksFile) {
        var _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              _context.p = 0;
              _context.n = 1;
              return function (specifier) {
                return new Promise(function (r) {
                  return r("".concat(specifier));
                }).then(function (s) {
                  return _interopRequireWildcard(require(s));
                });
              }(socksFile);
            case 1:
              return _context.a(2, _context.v);
            case 2:
              _context.p = 2;
              _t = _context.v;
              if (!(typeof require !== 'undefined')) {
                _context.n = 3;
                break;
              }
              return _context.a(2, require(socksFile));
            case 3:
              throw _t;
            case 4:
              return _context.a(2);
          }
        }, _callee, null, [[0, 2]]);
      }));
      function loadSocksFile(_x) {
        return _loadSocksFile.apply(this, arguments);
      }
      return loadSocksFile;
    }()
  }, {
    key: "detectWorkerSupport",
    value: function detectWorkerSupport() {
      if (isBrowser) {
        return typeof Worker !== 'undefined';
      } else if (isNode) {
        try {
          // Use dynamic import for worker_threads in ES modules
          return true; // We'll check this in createDefaultWorkerFactory
        } catch (e) {
          return false;
        }
      }
      return false;
    }
  }, {
    key: "createDefaultWorkerFactory",
    value: function createDefaultWorkerFactory() {
      if (isBrowser) {
        return function (socksFile) {
          return new Worker(socksFile);
        };
      } else if (isNode) {
        return /*#__PURE__*/function () {
          var _ref3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(socksFile) {
            var _yield$import, _Worker, _t2;
            return _regenerator().w(function (_context2) {
              while (1) switch (_context2.p = _context2.n) {
                case 0:
                  _context2.p = 0;
                  _context2.n = 1;
                  return Promise.resolve().then(function () {
                    return _interopRequireWildcard(require('worker_threads'));
                  });
                case 1:
                  _yield$import = _context2.v;
                  _Worker = _yield$import.Worker;
                  return _context2.a(2, new _Worker(socksFile, {
                    type: 'module'
                  }));
                case 2:
                  _context2.p = 2;
                  _t2 = _context2.v;
                  throw new Error('Worker threads not available');
                case 3:
                  return _context2.a(2);
              }
            }, _callee2, null, [[0, 2]]);
          }));
          return function (_x2) {
            return _ref3.apply(this, arguments);
          };
        }();
      }
      return function () {
        throw new Error('No worker support available');
      };
    }
  }, {
    key: "ready",
    value: function ready() {
      return this.readyPromise;
    }
  }, {
    key: "postMessage",
    value: function postMessage(data) {
      var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var transfer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      if (!this.isReady) {
        this.onMessageCallback(data, origin, transfer);
        return;
      }
      var message = 'data' in data ? data : {
        data: data
      };
      console.log("supports worker: ".concat(this.supportsWorker));
      if (this.supportsWorker) {
        // Handle different worker types
        if (isBrowser) {
          var _this$worker;
          (_this$worker = this.worker).postMessage.apply(_this$worker, _toConsumableArray([data, transfer.length > 0 ? transfer : undefined].filter(function (arg) {
            return !!arg;
          })));
        } else if (isNode) {
          this.worker.postMessage(data, transfer);
        }
      } else {
        this.socks.onMessageLocal(message, transfer);
      }
    }
  }, {
    key: "onMessage",
    value: function onMessage(callback) {
      var _this2 = this;
      this.onMessageCallback = callback;
      if (this.worker) {
        if (isBrowser) {
          this.worker.onmessage = callback;
        } else if (isNode) {
          // Check if worker has 'on' method (Node.js worker threads)
          if (typeof this.worker.on === 'function') {
            this.worker.on('message', callback);
          } else {
            // Fallback for mock workers or other implementations
            this.worker.onmessage = callback;
          }
        }
      }
      if (this.receivedBeforeReady.length) {
        console.log('messages received before socks loaded now replaying (not necessarily a problem, but loading out of order):');
        this.receivedBeforeReady.forEach(function (m) {
          return _this2.onMessageCallback && _this2.onMessageCallback.apply(_this2, _toConsumableArray(m));
        });
      }
    }
  }, {
    key: "onMessageLocal",
    value: function onMessageLocal(data, origin) {
      var transfer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      console.log("sending local message that would have been to origin ".concat(origin));
      if ((transfer === null || transfer === void 0 ? void 0 : transfer.length) > 0) {
        console.log("transfer ignored for ".concat(transfer.length, " transfer references"));
      }
      console.log("onMessageCallback ".concat(this.onMessageCallback));
      if (this.onMessageCallback) {
        this.onMessageCallback({
          data: data
        });
      } else {
        throw new Error('onMessageLocal should not be called without onMessageCallback defined');
      }
    }
  }, {
    key: "terminate",
    value: function terminate() {
      if (this.supportsWorker) {
        if (isBrowser) {
          this.worker.terminate();
        } else if (isNode) {
          this.worker.terminate();
        }
      } else {
        this.socks.terminate();
      }
    }
  }]);
}(); // Enhanced Socks with Browserify compatibility
var Socks = exports.Socks = /*#__PURE__*/function () {
  function Socks() {
    var self = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
    _classCallCheck(this, Socks);
    this.self = self;
    this.postsBeforeReady = [];
    this.isReady = false;
    this.sentReadyMessage = false;
  }
  return _createClass(Socks, [{
    key: "ready",
    value: function ready() {
      if (this.isWorkerSupported()) {
        this.postMessage("socks loaded");
        this.sentReadyMessage = true;
      } else {
        if (this.boots) {
          this.boots.onMessageLocal("socks loaded");
          this.sentReadyMessage = true;
        }
      }
      this.isReady = true;
      this.processReadyMessages();
    }
  }, {
    key: "processReadyMessages",
    value: function processReadyMessages() {
      var _this3 = this;
      if (this.sentReadyMessage) {
        this.postsBeforeReady.forEach(function (args) {
          return _this3.postMessage.apply(_this3, _toConsumableArray(args));
        });
        this.postsBeforeReady = [];
      }
    }
  }, {
    key: "enterBoots",
    value: function enterBoots(boots) {
      var _this$self;
      this.boots = boots;
      if (this.isReady && !this.sentReadyMessage) {
        this.ready();
      }
      // if enter boots is called, we don't have background worker support
      //  so set self to undefined as we want to keep this entirely local.
      if ((_this$self = this.self) !== null && _this$self !== void 0 && _this$self.onmessage) {
        this.onMessageCallback = this.self.onmessage;
      }
      this.self = undefined;
    }
  }, {
    key: "postMessage",
    value: function postMessage(data, origin /* = window?.document?.location?.origin*/) {
      var transfer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      if (!this.isReady) {
        this.postsBeforeReady.push([data, origin, transfer]);
        return;
      }
      var message = _typeof(data) === 'object' && 'data' in data ? data : {
        data: data
      };
      if (this.isWorkerSupported()) {
        if (isBrowser) {
          var _this$self2;
          (_this$self2 = this.self).postMessage.apply(_this$self2, _toConsumableArray([data, origin, transfer.length > 0 ? transfer : undefined].filter(function (arg) {
            return !!arg;
          })));
        } else if (isNode) {
          this.self.postMessage(data, transfer);
        }
      } else {
        this.boots.onMessageLocal(message, origin, transfer);
      }
    }
  }, {
    key: "onMessage",
    value: function onMessage(callback) {
      console.log('support ' + this.isWorkerSupported());
      if (this.isWorkerSupported()) {
        if (isBrowser) {
          this.self.onmessage = callback;
        } else if (isNode) {
          // Check if self has 'on' method (Node.js worker threads)
          if (typeof this.self.on === 'function') {
            this.self.on('message', callback);
          } else {
            // Fallback for mock workers or other implementations
            this.self.onmessage = callback;
          }
        }
      } else {
        this.onMessageCallback = callback;
      }
    }
  }, {
    key: "onMessageLocal",
    value: function onMessageLocal(data, origin) {
      var transfer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      console.log("sending local message that would have been to origin ".concat(origin));
      if ((transfer === null || transfer === void 0 ? void 0 : transfer.length) > 0) {
        console.log("transfer ignored for ".concat(transfer.length, " transfer references"));
      }
      console.log(this.onMessageCallback);
      if (this.onMessageCallback) {
        this.onMessageCallback(data);
      } else {
        throw new Error('onMessageLocal should not be called without onMessageCallback defined');
      }
    }
  }, {
    key: "terminate",
    value: function terminate() {
      var _this$self3, _this$self4;
      this.terminateCallback && this.terminateCallback();
      if (typeof ((_this$self3 = this.self) === null || _this$self3 === void 0 ? void 0 : _this$self3.terminate) === 'function') (_this$self4 = this.self) === null || _this$self4 === void 0 || _this$self4.terminate();
    }
  }, {
    key: "onTerminate",
    value: function onTerminate(callback) {
      // this is only called when we don't support service workers... beware1!!!1
      this.terminateCallback = callback;
    }
  }, {
    key: "isWorkerSupported",
    value: function isWorkerSupported() {
      if (isBrowser) {
        return typeof Worker !== 'undefined' && !!this.self;
      } else if (isNode) {
        return !!this.self;
      }
      return false;
    }
  }]);
}(); // Universal exports for all environments
// CommonJS compatibility for Browserify
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    WorkBoots: WorkBoots,
    Socks: Socks
  };
}

// AMD compatibility
if (typeof define === 'function' && define.amd) {
  define([], function () {
    return {
      WorkBoots: WorkBoots,
      Socks: Socks
    };
  });
}

// Global compatibility for browser
if (typeof window !== 'undefined') {
  window.WorkBoots = WorkBoots;
  window.Socks = Socks;
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":2,"worker_threads":1}]},{},[3])(3)
});


/***/ }),

/***/ "./src/algorithms/k-means-clustering.js":
/*!**********************************************!*\
  !*** ./src/algorithms/k-means-clustering.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clusterMaker": () => (/* binding */ clusterMaker),
/* harmony export */   "kmeans": () => (/* binding */ kmeans)
/* harmony export */ });


/**
  https://github.com/NathanEpstein/clusters
  License: MIT
*/

const clusterMaker = {

  data: getterSetter([], function(arrayOfArrays) {
    var n = arrayOfArrays[0].length;
    return (arrayOfArrays.map(function(array) {
      return array.length == n;
    }).reduce(function(boolA, boolB) { return (boolA & boolB) }, true));
  }),

  clusters: function() {
    var pointsAndCentroids = kmeans(this.data(), {k: this.k(), iterations: this.iterations() });
    var points = pointsAndCentroids.points;
    var centroids = pointsAndCentroids.centroids;
//sequencer add
    return centroids.map(function(centroid) {
      //sequencer add
      return {
        centroid: centroid.location(),
        points: points.filter(function(point) { return point.label() == centroid.label() }).map(function(point) { return point.location() }),
      };
    });
  },

  k: getterSetter(undefined, function(value) { return ((value % 1 == 0) & (value > 0)) }),

  iterations: getterSetter(Math.pow(10, 3), function(value) { return ((value % 1 == 0) & (value > 0)) }),

};

function kmeans(sequencer, data, config) {
  //sequencer add, 0
  // default k
  let k, iterations, points, centroids
  sequencer.add(() => {
    k = config.k || Math.round(Math.sqrt(data.length / 2));
    iterations = config.iterations;
  }, data, 0)

  //sequencer add, 1
  // initialize point objects with data
  sequencer.add(() => {
    points = data.map(function(vector) { return new Point(vector) });
  }, points, 1)

  //sequencer add, 1
  // intialize centroids randomly
  sequencer.add(() => {
    centroids = []
    for (var i = 0; i < k; i++) {
      centroids.push(new Centroid(points[i % points.length].location(), i));
    };
  }, points, 1)

  //sequencer add, 1
  // update labels and centroid locations until convergence
  //sequencer.add(() => {
  //}, points, 2)

  //because this was a prohibitively expensive call, we'll break this for loop up into a schedule of sequences
  // iterate should be used for anything expected to require more than 37000 operations
  sequencer.iterate(0, iter => iter < iterations, iter => iter+1,
    iter => {
      //sequencer insert, 3, maybe 2? reverse loop for sequence eval?
      //nested continuation might be better here?
      // otherwise we'll have to lift a variable in each iteration of the loop, and that could get relatively expensive
      // whereas nesting the continuation would mean that variables for each point / centroid won't get created until the current sequence is evaluated
      points.forEach(function(point) { point.updateLabel(centroids) });
      centroids.forEach(function(centroid) { centroid.updateLocation(points) });
    }, points, 1)

  //sequencer add, 0
  // return points and centroids
  sequencer.add(() => sequencer.resolve({
    points: points,
    centroids: centroids
  }), [], 0)

  return sequencer;
};

// objects
function Point(location) {
  var self = this;
  this.location = getterSetter(location);
  this.label = getterSetter();
  this.updateLabel = function(centroids) {
    var distancesSquared = centroids.map(function(centroid) {
      return sumOfSquareDiffs(self.location(), centroid.location());
    });
    self.label(mindex(distancesSquared));
  };
};

function Centroid(initialLocation, label) {
  var self = this;
  this.location = getterSetter(initialLocation);
  this.label = getterSetter(label);
  this.updateLocation = function(points) {
    var pointsWithThisCentroid = points.filter(function(point) { return point.label() == self.label() });
    if (pointsWithThisCentroid.length > 0) self.location(averageLocation(pointsWithThisCentroid));
  };
};

// convenience functions
function getterSetter(initialValue, validator) {
  var thingToGetSet = initialValue;
  var isValid = validator || function(val) { return true };
  return function(newValue) {
    if (typeof newValue === 'undefined') return thingToGetSet;
    if (isValid(newValue)) thingToGetSet = newValue;
  };
};

function sumOfSquareDiffs(oneVector, anotherVector) {
  var squareDiffs = oneVector.map(function(component, i) {
    return Math.pow(component - anotherVector[i], 2);
  });
  return squareDiffs.reduce(function(a, b) { return a + b }, 0);
};

function mindex(array) {
  var min = array.reduce(function(a, b) {
    return Math.min(a, b);
  });
  return array.indexOf(min);
};

function sumVectors(a, b) {
  return a.map(function(val, i) { return val + b[i] });
};

function averageLocation(points) {
  var zeroVector = points[0].location().map(function() { return 0 });
  var locations = points.map(function(point) { return point.location() });
  var vectorSum = locations.reduce(function(a, b) { return sumVectors(a, b) }, zeroVector);
  return vectorSum.map(function(val) { return val / points.length });
};

function __kmeans(data, config) {
  // default k
  var k = config.k || Math.round(Math.sqrt(data.length / 2));
  var iterations = config.iterations;

  // initialize point objects with data
  var points = data.map(function(vector) { return new Point(vector) });

  // intialize centroids randomly
  var centroids = [];
  for (var i = 0; i < k; i++) {
    centroids.push(new Centroid(points[i % points.length].location(), i));
  };

  // update labels and centroid locations until convergence
  for (var iter = 0; iter < iterations; iter++) {
    points.forEach(function(point) { point.updateLabel(centroids) });
    centroids.forEach(function(centroid) { centroid.updateLocation(points) });
  };

  // return points and centroids
  return {
    points: points,
    centroids: centroids
  };

};


/***/ }),

/***/ "./src/algorithms/lfn.js":
/*!*******************************!*\
  !*** ./src/algorithms/lfn.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_": () => (/* binding */ _)
/* harmony export */ });
/**
A light native alternative to underscore, as the fitbit compiler was not able to handle the callstack size :(
Many of the solutions are pulled from https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_flatten
Alternatively I may pull directly from lodash or underscore
Licenses are inherited from underscore including MIT and Apache 2.0
*/
const makeSelect = (comparator) => (a, b) => comparator(a, b) ? a : b
const pluck = (list, name) => list.map(x => x[name])

const first = (list, valueOrPredicate) => {
  let i = 0

  if (typeof valueOrPredicate !== 'function') {
      let val = valueOrPredicate
      valueOrPredicate = (newVal) => newVal === val
  }
  while (i < list.length && !valueOrPredicate(list[i])) i++
  return i < list.length ? list[i] : undefined
}

const all = (list, valueOrPredicate) => {
  let i = 0
  if (typeof valueOrPredicate !== 'function') {
      let val = valueOrPredicate
      valueOrPredicate = (newVal) => newVal === val
  }
  while (i < list.length && valueOrPredicate(list[i])) i++
  return i == list.length
}

//from underscore.js
// Returns whether an object has a given set of `key:value` pairs.
const isMatch = function(object, attrs) {
  let keys = Object.keys(attrs), length = keys.length;
  if (object == null) return !length;
  let obj = Object(object);
  for (let i = 0; i < length; i++) {
    let key = keys[i];
    if (attrs[key] !== obj[key] || !(key in obj)) return false;
  }
  return true;
}

//from underscore.js
// accepts an array to retrieve the properties in an object recursively
const deepGet = function(obj, path) {
  const length = path.length;
  for (let i = 0; i < length; i++) {
    if (obj == null) return void 0;
    obj = obj[path[i]];
  }
  return length ? obj : void 0;
}

//from underscore.js
// A helper function to wrap callbacks appropriately, and safeguard against empty callbacks etc
const cb = function(value, context, argCount) {
    if (value == null || value == undefined) return (v) => v;
    if (typeof value === 'function') return value.bind(context)
    if (typeof value === 'object' && !Array.isArray(value)) return v => isMatch(v, value);
    //at this point we're only left with a string or a number, so we'll retrieve either an index or a property
    return Array.isArray(value) ? v => deepGet(v, value) : v => v[value];
}

const _ = {
    uniq(list) { return [...new Set(list)] },
    pairs(object) { return Object.entries(object) },
    first: first,
    keys: Object.keys,
    sum(list) { return list.reduce(function(memo, num){ return memo + num; }, 0) },
    flatten(list) { return list.reduce( (a, b) => a.concat(b), []) },
    minBy(collection, key) {
      // slower because need to create a lambda function for each call...
      const select = (a, b) => a[key] <= b[key] ? a : b
      return collection.reduce(select, {})
    },
    maxBy(collection, key) {
      // slower because need to create a lambda function for each call...
      const select = (a, b) => a[key] >= b[key] ? a : b
      return collection.reduce(select, {})
    },
    min(collection, iteratee) {
      let comparitor = makeSelect((a, b) => a <= (iteratee !== undefined ? iteratee(b) : b))
      let initial = collection.length > 0 ? collection[0] : undefined
      if (iteratee !== undefined) initial = iteratee(initial)
      return collection.reduce(comparitor, initial)
    },
    max(collection, iteratee) {
      let comparitor = makeSelect((a, b) => a >= (iteratee !== undefined ? iteratee(b) : b))
      let initial = collection.length > 0 ? collection[0] : undefined
      if (iteratee !== undefined) initial = iteratee(initial)
      return collection.reduce(comparitor, initial)
    },
    pluck: pluck,
    sortby(obj, iteratee, context) {
      //sourced and modified directly from underscore
      var index = 0;
      iteratee = cb(iteratee, context);
      return pluck(obj.map(function(value, key, list) {
        return {
          value: value,
          index: index++,
          criteria: iteratee(value, key, list)
        };
      }).sort(function(left, right) {
        var a = left.criteria;
        var b = right.criteria;
        if (a !== b) {
          if (a > b || a === void 0) return 1;
          if (a < b || b === void 0) return -1;
        }
        return left.index - right.index;
      }), 'value');
    },
    any(list, valueOrPredicate) {
      return first(list, valueOrPredicate) !== undefined
    },
    all: all
  }

const test = () => {
  let fails = []

  if (_.min([1,2,3,4]) != 1) fails.push('min')
  if (_.max([1,2,3,4]) != 4) fails.push('max')
  let tosort = [{value:2}, {value:1}, {value:3}, {value:4}, {value:-1}]
  if (_.sortby(tosort, 'value')[0].value != -1) fails.push('sortby:string prop')
  if (_.sortby(tosort, v => v.value)[0].value != -1) fails.push('sortby:function')
  if (!_.any([1,2,3,4,5,6,'bloop'], v => v == 'bloop')) fails.push('any:predicate')
  if (!_.any([1,2,3,4,5,6,'bloop'], 'bloop')) fails.push('any:value')
  if (_.pluck([{a: 'youch', b: 'b'}, {a: 'stop that', b: 'b'}, {a: 'quit it', b: 'b'}], 'a').join(' ') != 'youch stop that quit it') fails.push('pluck')
  if (!isMatch(_.minBy(tosort, 'value'), {value:-1})) fails.push('minBy')
  if (!isMatch(_.maxBy(tosort, 'value'), {value:4})) fails.push('maxBy')
  if (!isMatch(_.keys({a:'a', b:'b', c:'c'}), ['a', 'b', 'c'])) fails.push('keys')
  if (!isMatch(_.flatten(_.pairs({a:'a', b:'b', c:'c'})), ['a', 'a', 'b', 'b', 'c', 'c'])) fails.push('pairs')
  if (!isMatch(_.uniq([1,1,1,1,1,2,2,2,2,2,2,3,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5]), [1,2,3,4,5])) fails.push('uniq')
  if (_.sum([1,2,3,4]) != 10) fails.push('sum')
  if (!isMatch(_.flatten([1,[2,3,4],5]), [1,2,3,4,5])) fails.push('flatten')
  if (!_.all([1,2,3,4,5,6], v => v > 0)) fails.push('all:predicate')
  if (!_.all([0,0,0,0,0,0,0,0], 0)) fails.push('all:value')
  if (_.all([1,0,0,0,0,0,0],0)) fails.push('all:value:negative')
  if (_.all([0,1,2,3,4,5,6], v => v > 0)) fails.push('all:predicate:negative')

  return fails
}


/***/ }),

/***/ "./src/algorithms/sequencer.js":
/*!*************************************!*\
  !*** ./src/algorithms/sequencer.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Sequence": () => (/* binding */ Sequence),
/* harmony export */   "SequencePriorityQueue": () => (/* binding */ SequencePriorityQueue)
/* harmony export */ });
/* harmony import */ var _lfn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lfn */ "./src/algorithms/lfn.js");


const noop = () => {}

/**
A generic sequencer designed to allow for processor / memory heavy on a lighter load
Sequences should be as lazy as possible to defer massive allocations
If it helps at all, think about sequence like a promise with specific functionality for lists, and complexity
*/
class Sequence {
    sequences = []
    name = ""
    result = undefined
    thens = []

    constructor(name) {
        this.name = name
    }

    insertAt(sequence, data, index, cyclomaticComplexity) {
        this.sequences.splice(index, 0, {
            exec: sequence,
            data: data,
            cyclomaticComplexity: cyclomaticComplexity
        }, index)
    }

    append(sequence, data, cyclomaticComplexity) {
        this.sequences.push({
            exec: sequence,
            data: data,
            cyclomaticComplexity: cyclomaticComplexity
        })
    }

    add(sequence, data, cyclomaticComplexity) {
      this.append(sequence, data, cyclomaticComplexity)
    }

    enqueue(sequence, data, cyclomaticComplexity) {
        this.sequences.splice(0, 0, {
            exec: sequence,
            data: data,
            cyclomaticComplexity: cyclomaticComplexity
        })
    }

    /**
     * Creates a sequence for each iteration of the loop
     * @param {int} initial the initial value
     * @param {function<bool>} predicate loop predicate
     * @param {function<int>} incrementer the new value for the index
     * @param {function<func or value>} sequence a function
     * @param {value} data the value for the method
     * @param {int} cyclomaticComplexity the cyclomatic complexity for each iteration

     * @note this should be improved to handle variable range inputs - say you have to iterate through
     *   many thousands of inputs, you could set max per iteration to 50, and it could use that to fill
     *   the left over processing space, maybe pass it as a param to the exec function
     */
    iterate(initial, predicate, incrementer, sequenceFn, data, cyclomaticComplexity, useAdd = true) {
        //we want to add a sequence that iterates over the sequence, pushing another iteration if !!predicate()
        let index = initial;
        // TODO: review: add and enqueue are kind of confusing, as queues are FIFO,
        //               and [add]'ed sequences get FIFO, whereas enqueue is FILO
        (useAdd ? this.add.bind(this) : this.enqueue.bind(this))(() => {
            if (predicate(index)) {
                sequenceFn()

                index = incrementer(index)
                this.iterate(index, predicate, incrementer, sequenceFn, data, cyclomaticComplexity, false)
            }
        }, data, cyclomaticComplexity)
    }

    resolve(value) {
        //resolve with a value, ending exec of this sequence
        this.result = value
        this.sequences = []
        if (this.thens?.length > 0) {
          this.thens.forEach(then => then(this.result, null))
        }
        return this;
    }

    reject(error) {
        this.sequences = []
        if (this.thens?.length > 0) {
          this.thens.forEach(then => then(undefined, error))
        }
        return this;
    }

    then(func = noop) {
      return new Promise((resolve, reject) => {
        this.thens.push((result, error) => {
          if (error) {
            reject(error)
            return
          }

          resolve(func(result))
        })
      })
    }

    exec() {
        if (this.sequences.length > 0) {
            return this.sequences.shift().exec()
        } else {
            return undefined
        }
    }

    execDesc() {
      if (this.sequences.length > 0) {
        return this.sequences.pop().exec()
      } else {
        return undefined
      }
    }

    hasExec() {
        return this.sequences.length > 0
    }
}

const MAX_COMPLEXITY = 37000
class SequencePriorityQueue {
    sequences = []

    addSequence() {

    }

    completeSequence() {
        return new Promise((resolve, reject) => {
            //we can only handle ~37000 iterations per main loop exec
            // what does that mean for the sequencer?
            // uh, it means that we should pay attention to the cyclomatic complexity vs the data size
            // our highest granularity data set will be heart rate / acc / gyrometer
            // highest == 60 / minute .. 1 / second -> highest duration is 30 minutes -> 30 * 60 = 1800
            // so perhaps we should take the length of the dataset * sequence.cyclomaticComplexity
            // datasets that have no cyclomatic complexity or constant speed, should return 0
            // this is a problem though, as 193 ^ 2 === 37249, so possibly we should be returning earlier,
            // and the fitness functions will get super muddy with continuations and counters.
            this.scheduleSequence(resolve)
        })
    }

    scheduleSequence(resolve) {
        this.sequenceIntervalId = setTimeout(() => {
            this.getSequencesToExec().forEach(s => s.exec())

            if (_lfn__WEBPACK_IMPORTED_MODULE_0__._.all(this.sequence, s => !s.hasExec())) {
                clearTimeout(this.sequenceIntervalId)
                resolve(this.sequences.reduce((m,c) => m[c.name] = c.result, {}))
            } else {
                this.scheduleSequence()
            }
        }, 1000)
    }

    getSequencesToExec() {
        let sum = 0
        return _lfn__WEBPACK_IMPORTED_MODULE_0__._.sortBy(sequences, s => s.cyclomaticComplexity).reduce((memo, curr) => {
            //don't include this sequence if we already got a result, or if exec is null
            if (curr.result !== undefined || curr.sequence === undefined) {
                return memo
            }

            let currentComplexity = Math.pow(typeof curr.data === 'number' ? curr.data : curr.data.length, curr.cyclomaticComplexity)

            if (currentComplexity > MAX_COMPLEXITY) {
                throw new Error('MAX_COMPLEXITY exceeded by sequence ' + curr.name + ' with complexity count: ' + currentComplexity)
            }

            //otherwise just include it if adding it means we're under the max complixity
            if (sum + currentComplexity <= MAX_COMPLEXITY) {
                sum += currentComplexity
                memo.push(curr)
            }

            return memo
        }, [])
    }
}

/**

function complexFunction(sequencer, data) {
    let someResult = null
    sequencer.add(() => {
        someResult = data.map(d => complexStuff(d))

        sequencer.add(() => {
            //if data is mutated or reliant on a lower scope
            //nested sequencer.add is a good call
            someResult = someResult.map(d => moreComplexStuff(d))
        }, data, 2)
    }, data, 2) //powers

    //otherwise, procedural calls are fine
    sequencer.add(() => {
        let fitness = someResult.map(d => soMuchComplexityWowVeryMath(d)).reduce(fitnessssss)

        return snakes(fitness).bunchOfSnakes(WHY_ALWAYS_SNAKES("?"))
    }, 3)

    return sequencer
}

function schedulingExample() {
    let sequencer = SequencePriorityQueue()
    sequencer.addSequence(complexFunction(new Sequencer("complexFunction"), slightlyConfusingMetricDataOrTraining))

    sequencer.completeSequence().then(results => {
        //probably change results set to include name or just make a map or add names
        rejoiceAsItisSecondsLaterButWeveDoneCoolMath(results)
    })
}


**/


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*****************************************************!*\
  !*** ./src/algorithms/k-means-clustering.worker.js ***!
  \*****************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "socks": () => (/* binding */ socks)
/* harmony export */ });
/* harmony import */ var _sequencer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sequencer */ "./src/algorithms/sequencer.js");
/* harmony import */ var _k_means_clustering__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./k-means-clustering */ "./src/algorithms/k-means-clustering.js");
/* harmony import */ var tinycolor2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tinycolor2 */ "./node_modules/tinycolor2/esm/tinycolor.js");
// Patch environment detection for work-boots in Web Worker context
// Work-boots expects window/document for browser detection, but workers only have 'self'
if (typeof window === 'undefined' && typeof self !== 'undefined') {
  // Make work-boots think we're in a browser by providing minimal window/document
  globalThis.window = self;
  globalThis.document = { }; // Minimal document object
  console.log('Worker: Patched environment for work-boots browser detection');
}

const workbootsExports = __webpack_require__(/*! workboots */ "./node_modules/workboots/dist/work-boots.browser.js");
console.log('Worker: Available objects:');
console.log('self.Socks:', self.Socks);
console.log('self.WorkBoots:', self.WorkBoots);
console.log('self.WorkBoots keys:', self.WorkBoots ? Object.keys(self.WorkBoots) : 'undefined');

// Debug environment detection
console.log('Worker environment detection:');
console.log('typeof window:', typeof window);
console.log('typeof document:', typeof document);
console.log('typeof process:', typeof process);
console.log('typeof self:', typeof self);

// Try the nested structure like in main thread - use the same pattern as main thread
const Socks = self.WorkBoots && self.WorkBoots.Socks;

console.log('Worker: About to create Socks instance');
console.log('Worker: Socks constructor:', Socks);




// Ensure Socks constructor is available before creating instance
if (!Socks) {
  console.error('Worker: Socks constructor not found! Available objects:', {
    'self.Socks': self.Socks,
    'self.WorkBoots': self.WorkBoots,
    'workbootsExports': workbootsExports
  });
  throw new Error('Socks constructor not available');
}

const socks = new Socks(self);

console.log('Worker: Socks instance created:', socks);

//todo: move this to the Socks class constructor, as a warning for missing socks.ready() call
// easy to do, even if this is cheesy
// Add timeout warning for missing socks.ready() call
let readyCalled = false;
setTimeout(() => {
  if (!readyCalled) {
    console.warn('WARNING: socks.ready() was not called within 3000ms! This may cause communication issues.');
  }
}, 3000);

socks.onMessage(({ data }) => {
  if ('imageData' in data) {
    startClustering(data);
  }
});

const PROGRESS_UPDATE_STEP = 10;
let progressCounter = 0;
const startClustering = ({ imageData, iterations = 10, palletSize = 10, width, height }) => {
  progressCounter = 0;
  const hsvArray = [];
  const colors = [];
  for (let i = 0; i < imageData.length; i += 4) {
    // Modify pixel data
    const rgba = (0,tinycolor2__WEBPACK_IMPORTED_MODULE_2__.default)({
      r: imageData[i + 0],
      g: imageData[i + 1],
      b: imageData[i + 2],
      a: imageData[i + 3]
    });

    const {
      h, s, v
    } = rgba.toHsv();
    hsvArray.push([h,s,v]);
    colors.push({
      x: (i / 4) % width,
      y: Math.floor(i / 4 / width),
      color: rgba.toHexString(),
      hsv: [h,s,v]
    });
  }

  const sequence = new _sequencer__WEBPACK_IMPORTED_MODULE_0__.Sequence();

  (0,_k_means_clustering__WEBPACK_IMPORTED_MODULE_1__.kmeans)(sequence, hsvArray, { iterations, k: palletSize })
    .then(({ centroids, points }) => {
      finished({ centroids, imageData, colors });
    });

  while (sequence.hasExec()) {
    sequence.exec();
    progressUpdate();
  }
}

const progressUpdate = () => {
  progressCounter++;
  const percentage = Math.min(progressCounter * 2, 99); // Rough progress estimation
  socks.postMessage({ progressUpdate: percentage });
}

const v3distance = (v1, v2) => {
  const x = v1[0] - v2[0];
  const y = v1[1] - v2[1];
  const z = v1[2] - v2[2];
  return Math.pow(x*x + y*y + z*z, 0.5)
}

const finished = ({ centroids, imageData, colors }) => {
  const graphNodes = centroids
    .map(c => c.location())
    .map(c => {
      const [h,s,v] = c;
      const centroidHSV = [h,s,v];
      const color = (0,tinycolor2__WEBPACK_IMPORTED_MODULE_2__.default)({ h,s,v }).toHexString();
      let ex = undefined;
      colors.reduce((a, c) => {
        const distance = v3distance(centroidHSV, c.hsv);
        if (distance < a) {
          ex = c;
          return distance;
        } else {
          return a;
        }
      }, 1000000);
      // this could be a little better... :shrug:
      const example = ex;

      if (!example) {
        console.log(`unable to find color example for color: ${color}`);
        return undefined;
      }
      return {
        x: example.x,
        y: example.y,
        color: color
      };
    })
    .filter(c => !!c);

  socks.postMessage({ graphNodes });
}

socks.ready();
readyCalled = true;



})();

/******/ })()
;
//# sourceMappingURL=k-means-clustering-worker.js.map