{"version":3,"sources":["webpack://directed-color-picker/./node_modules/tinycolor2/esm/tinycolor.js","webpack://directed-color-picker/./node_modules/workboots/dist/work-boots.browser.js","webpack://directed-color-picker/./src/algorithms/k-means-clustering.js","webpack://directed-color-picker/./src/algorithms/lfn.js","webpack://directed-color-picker/./src/algorithms/sequencer.js","webpack://directed-color-picker/webpack/bootstrap","webpack://directed-color-picker/webpack/runtime/define property getters","webpack://directed-color-picker/webpack/runtime/hasOwnProperty shorthand","webpack://directed-color-picker/webpack/runtime/make namespace object","webpack://directed-color-picker/./src/algorithms/k-means-clustering.worker.js"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,4CAA4C;AAC5C,4CAA4C;AAC5C;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,WAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2DAA2D,wBAAwB;;AAEnF;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8EAA8E,4BAA4B,gBAAgB;AAC1H,8EAA8E,2BAA2B,gBAAgB;AACzH,qDAAqD,oDAAoD,gBAAgB;AACzH,qDAAqD,oDAAoD,gBAAgB;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,KAAK,kBAAkB,YAAY,kBAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE,cAAc,EAAE,cAAc,EAAE;AAC7D,2BAA2B,EAAE,cAAc,EAAE,cAAc,EAAE;AAC7D,2BAA2B,EAAE,cAAc,EAAE,cAAc,EAAE,cAAc,EAAE;AAC7E,2BAA2B,EAAE,cAAc,EAAE,cAAc,EAAE,cAAc,EAAE;AAC7E;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,UAAU,OAAO,UAAU,OAAO,SAAS;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;;;;;;;;;;;AC3pChC,aAAa,2DAA2D,mBAAmB,gDAAgD,aAAa,KAAK,MAAM,gCAAgC,SAAS,qCAAqC,SAAS,mCAAmC,OAAO,KAAK,OAAO,mBAAmB,aAAa,0BAA0B,mBAAmB,kBAAkB,gBAAgB,UAAU,UAAU,0CAA0C,wBAAwB,oBAAoB,8CAA8C,kCAAkC,YAAY,YAAY,mCAAmC,iBAAiB,eAAe,sBAAsB,oBAAoB,kDAAkD,WAAW,YAAY,SAAS,SAAS,KAAK;;AAE9zB,CAAC,GAAG;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;AAEtC,CAAC,GAAG;AACJ,2BAA2B;AAC3B;;AAEA;AACA;AACA,CAAC;AACD;AACA,qBAAqB,2BAA2B,oGAAoG,iBAAiB,EAAE,iBAAiB,qHAAqH,EAAE,aAAa;AAC5T,gCAAgC,+GAA+G;AAC/I,+BAA+B,6JAA6J;AAC5L,4CAA4C,SAAS,0DAA0D,WAAW,+BAA+B,6NAA6N,EAAE;AACxX,8BAA8B,iHAAiH;AAC/I,gCAAgC,mDAAmD;AACnF,kCAAkC,+CAA+C,8BAA8B,OAAO,kBAAkB,UAAU;AAClJ,yBAAyB,2NAA2N,uEAAuE,yBAAyB,+FAA+F,8DAA8D,+CAA+C,+DAA+D,wCAAwC,EAAE,GAAG,mBAAmB,0BAA0B,+BAA+B,OAAO,oCAAoC,4OAA4O,EAAE,0BAA0B,iBAAiB,EAAE,4BAA4B,4DAA4D,4CAA4C,2BAA2B,GAAG,uEAAuE,MAAM,gBAAgB,mCAAmC,8EAA8E,uBAAuB,+BAA+B,EAAE,uIAAuI,OAAO,EAAE,8DAA8D,EAAE,YAAY,qBAAqB,EAAE,UAAU,OAAO,EAAE,EAAE,SAAS,qBAAqB,GAAG,EAAE,kBAAkB,EAAE,YAAY,wBAAwB,gCAAgC,yCAAyC,2BAA2B,4DAA4D,kBAAkB,aAAa,EAAE,yFAAyF,gBAAgB,qNAAqN,EAAE,6bAA6b,aAAa,EAAE,mDAAmD,6BAA6B,EAAE,4CAA4C,SAAS,cAAc,EAAE,IAAI;AACj5F,0CAA0C,+BAA+B,MAAM,KAAK,QAAQ,EAAE,EAAE,YAAY,OAAO,EAAE,gEAAgE,mBAAmB,yCAAyC,8BAA8B,EAAE,EAAE,EAAE,kBAAkB,2DAA2D,6DAA6D,EAAE,kCAAkC;AACnc,kDAAkD,MAAM,8BAA8B,EAAE,YAAY,kBAAkB,EAAE,+CAA+C;AACvK,+BAA+B,qBAAqB,6BAA6B,qCAAqC,uBAAuB,oBAAoB,uDAAuD,EAAE,qBAAqB,wDAAwD,EAAE,eAAe,EAAE,EAAE,GAAG;AAC/T,gCAAgC,iFAAiF;AACjH,kCAAkC,gBAAgB,cAAc,OAAO,cAAc,+IAA+I,EAAE;AACtO,gCAAgC,qHAAqH,eAAe,KAAK;AACzK,4BAA4B,mCAAmC,4CAA4C;AAC3G,6BAA6B,4CAA4C,+BAA+B,oBAAoB,mCAAmC,sCAAsC,qEAAqE,EAAE,8CAA8C;AAC1T,wCAAwC,4EAA4E,2EAA2E,uCAAuC,gBAAgB,iCAAiC,8EAA8E,qBAAqB,+BAA+B,aAAa,EAAE,2CAA2C,oKAAoK,UAAU,EAAE,QAAQ;AAC3oB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gGAAgG,aAAa;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,sBAAsB;AACtB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH,CAAC,GAAG;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC,GAAG;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC,aAAa,yJAAyJ;AACvK,CAAC,EAAE,gCAAgC,EAAE,GAAG;AACxC,CAAC;;;;;;;;;;;;;;;;AC3pBW;;AAEZ;AACA;AACA;AACA;;AAEO;;AAEP;AACA;AACA;AACA;AACA,KAAK,iCAAiC,yBAAyB;AAC/D,GAAG;;AAEH;AACA,kDAAkD,4CAA4C;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2CAA2C,uBAAuB,0BAA0B;AAC3I;AACA,KAAK;AACL,GAAG;;AAEH,8CAA8C,0CAA0C;;AAExF,6DAA6D,0CAA0C;;AAEvG;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,wCAAwC,2BAA2B;AACnE,GAAG;;AAEH;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+BAA+B;AACrE,4CAA4C,kCAAkC;AAC9E,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gEAAgE,uCAAuC;AACvG;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,4CAA4C,eAAe;AAC3D;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,iCAAiC,oBAAoB;AACrD;;AAEA;AACA,wDAAwD,WAAW;AACnE,8CAA8C,0BAA0B;AACxE,mDAAmD,0BAA0B;AAC7E,sCAAsC,6BAA6B;AACnE;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,2BAA2B;;AAErE;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC,oCAAoC,+BAA+B;AACnE,0CAA0C,kCAAkC;AAC5E;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,gBAAgB,4BAA4B;AAC5C,mBAAmB,gCAAgC;AACnD;AACA;AACA,eAAe,wCAAwC,mBAAmB,EAAE,MAAM;AAClF,mBAAmB,iDAAiD;AACpE;AACA;AACA;AACA,yCAAyC;AACzC,KAAK;AACL;AACA;AACA;AACA,yCAAyC;AACzC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ,GAAG,QAAQ,GAAG,QAAQ,GAAG,QAAQ,GAAG,SAAS;AACtE;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB,GAAG,uBAAuB,GAAG,qBAAqB;AACrF,0CAA0C,SAAS;AACnD,0CAA0C,QAAQ;AAClD,uBAAuB,oBAAoB;AAC3C,kCAAkC,oBAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;AChJyB;;AAEzB;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,IAAI;AACnB,eAAe,eAAe;AAC9B,eAAe,cAAc;AAC7B,eAAe,wBAAwB;AACvC,eAAe,MAAM;AACrB,eAAe,IAAI;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACO;AACP;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA,gBAAgB,uCAAK;AACrB;AACA,+EAA+E;AAC/E,aAAa;AACb;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,0CAAQ;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;;AAGA;;;;;;;UC/NA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA,yBAAyB,GAAG;AAC5B;AACA;;AAEA,yBAAyB,mBAAO,CAAC,sEAAW;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACuC;AACO;AACX;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,kBAAkB,OAAO;AACzB;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA,gCAAgC,qIAAqI;AACrK;;AAEA,kDAAkD,MAAM,GAAG,OAAO,UAAU,WAAW,WAAW,WAAW;;AAE7G;AACA;AACA;AACA,mEAAmE;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oDAAoD;;AAEpD;AACA,qB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB,OAAO,WAAW;AAC3E,2CAA2C,wBAAwB;AACnE;;AAEA;AACA;AACA,iCAAiC,YAAY,uBAAuB,cAAc;;AAElF;AACA,uB;AACA;AACA,4BAA4B,YAAY;AACxC,KAAK;;AAEL;AACA;;AAEA;AACA,WAAW,uDAAuD;;AAElE,kCAAkC,iBAAiB,GAAG,kBAAkB,IAAI,2BAA2B;;AAEvG;AACA;AACA;AACA;AACA,4CAA4C;;AAE5C,mBAAmB,4BAA4B;AAC/C,mBAAmB,mDAAS;AAC5B;AACA;AACA;AACA;AACA,OAAO;;AAEP,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,gDAAQ;;AAEjC;AACA;AACA,uDAAuD,gBAAgB,WAAW,WAAW;AAC7F;AACA,wBAAwB;;AAExB,mCAAmC,YAAY,e;AAC/C;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,4CAA4C,YAAY,IAAI,4BAA4B,eAAe,qBAAqB;;AAE5H;AACA,kDAAkD,YAAY;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qFAAqF;AACrF,yB;AACA;AACA,6BAA6B,YAAY,IAAI,iBAAiB,GAAG,kBAAkB;AACnF,OAAO;;AAEP,KAAK;AACL,2CAA2C,YAAY;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wB;AACA;AACA,6CAA6C,wBAAwB;AACrE,MAAM;;AAEN;AACA,wB;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,mDAAmD;;AAEnD,0CAA0C,qBAAqB,0BAA0B,eAAe;;AAExG,oBAAoB,sBAAsB;AAC1C,oBAAoB,mDAAS;AAC7B;AACA;AACA;AACA;AACA,QAAQ;;AAER,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA,6B;AACA;AACA,iDAAiD,yCAAyC;AAC1F,WAAW;AACX;AACA;;AAEA;AACA,wB;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,e;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA,wBAAwB,mDAAmD;AAC3E;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C,oBAAoB,uBAAuB;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,mCAAmC;AACzD,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;;AAEA;AACA;AACA,iDAAiD,EAAE,eAAe,gBAAgB;;AAElF;AACA;AACA;;AAEA,iBAAiB,qCAAqC;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB,iBAAiB;AAC1C;AACA;;AAEA;AACA;AACA,iDAAiD,EAAE,eAAe,gBAAgB;;AAElF;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,qCAAqC;AACtD;AACA,yCAAyC;AACzC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH,yBAAyB,cAAc;AACvC;AACA;;AAEA;AACA;AACA,mD;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,oBAAoB;AACpB;;AAEA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;;AAEA,4BAA4B,EAAE,KAAK,aAAa;;AAEhD;AACA,oDAAoD;AACpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wDAAwD,cAAc,gBAAgB,YAAY;AAClG,qBAAqB;AACrB;;AAEA;AACA;AACA,uDAAuD;AACvD,qBAAqB,6BAA6B;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,wJAAwJ;AAC3K;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,kCAAkC,aAAa,KAAK,uCAAuC;AAC3F,oCAAoC,eAAe;AACnD,0CAA0C,oBAAoB;AAC9D,oCAAoC,WAAW;;AAE/C;AACA;AACA;AACA;AACA,kCAAkC,yBAAyB;AAC3D;;AAEA;AACA;AACA;AACA,8BAA8B,MAAM,QAAQ,aAAa,IAAI,qBAAqB,KAAK,qBAAqB;AAC5G,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,gBAAgB,WAAW;AAC3B;AACA;;AAEA;AACA;AACA;AACA,yDAAyD,4BAA4B,IAAI,oCAAoC,KAAK,oCAAoC,eAAe,oBAAoB,cAAc,+BAA+B;AACtP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC,cAAc,IAAI,sBAAsB,KAAK,sBAAsB;AAC5G,OAAO;AACP,yCAAyC,cAAc,IAAI,sBAAsB,KAAK,sBAAsB;AAC5G;AACA;;AAEA,+BAA+B,yBAAyB,0BAA0B,oBAAoB;;AAEtG;AACA;AACA;;AAEA,0DAA0D,WAAW;AACrE;AACA;AACA;AACA,OAAO;;AAEP,uDAAuD,0BAA0B;;AAEjF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC;AACvC,SAAS;AACT;;AAEA;AACA;AACA,0CAA0C,WAAW;;AAErD,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA,8CAA8C,aAAa,IAAI,qBAAqB,KAAK,qBAAqB;AAC9G;AACA;;AAEA,kCAAkC,yBAAyB;AAC3D,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,mDAAS,EAAE,QAAQ;;AAEvC;AACA;;AAEA;AACA,+DAA+D,MAAM;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,qBAAqB,aAAa;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mDAAS,EAAE,2CAA2C;AAC9E,wBAAwB,mDAAS,EAAE,2CAA2C;AAC9E;AACA;AACA;AACA,4BAA4B,mDAAS,EAAE,2CAA2C;AAClF,4BAA4B,mDAAS,EAAE,2CAA2C;AAClF;AACA;AACA;AACA;AACA,4BAA4B,mDAAS,EAAE,2CAA2C;AAClF,4BAA4B,mDAAS,EAAE,2CAA2C;AAClF;AACA;AACA,4CAA4C,mBAAmB,QAAQ,mBAAmB,QAAQ,mBAAmB;AACrH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAIE","file":"k-means-clustering-worker.js","sourcesContent":["// This file is autogenerated. It's used to publish ESM to npm.\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\n// https://github.com/bgrins/TinyColor\n// Brian Grinstead, MIT License\n\nvar trimLeft = /^\\s+/;\nvar trimRight = /\\s+$/;\nfunction tinycolor(color, opts) {\n  color = color ? color : \"\";\n  opts = opts || {};\n\n  // If input is already a tinycolor, return itself\n  if (color instanceof tinycolor) {\n    return color;\n  }\n  // If we are called as a function, call using new instead\n  if (!(this instanceof tinycolor)) {\n    return new tinycolor(color, opts);\n  }\n  var rgb = inputToRGB(color);\n  this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;\n  this._gradientType = opts.gradientType;\n\n  // Don't let the range of [0,255] come back in [0,1].\n  // Potentially lose a little bit of precision here, but will fix issues where\n  // .5 gets interpreted as half of the total, instead of half of 1\n  // If it was supposed to be 128, this was already taken care of by `inputToRgb`\n  if (this._r < 1) this._r = Math.round(this._r);\n  if (this._g < 1) this._g = Math.round(this._g);\n  if (this._b < 1) this._b = Math.round(this._b);\n  this._ok = rgb.ok;\n}\ntinycolor.prototype = {\n  isDark: function isDark() {\n    return this.getBrightness() < 128;\n  },\n  isLight: function isLight() {\n    return !this.isDark();\n  },\n  isValid: function isValid() {\n    return this._ok;\n  },\n  getOriginalInput: function getOriginalInput() {\n    return this._originalInput;\n  },\n  getFormat: function getFormat() {\n    return this._format;\n  },\n  getAlpha: function getAlpha() {\n    return this._a;\n  },\n  getBrightness: function getBrightness() {\n    //http://www.w3.org/TR/AERT#color-contrast\n    var rgb = this.toRgb();\n    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;\n  },\n  getLuminance: function getLuminance() {\n    //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n    var rgb = this.toRgb();\n    var RsRGB, GsRGB, BsRGB, R, G, B;\n    RsRGB = rgb.r / 255;\n    GsRGB = rgb.g / 255;\n    BsRGB = rgb.b / 255;\n    if (RsRGB <= 0.03928) R = RsRGB / 12.92;else R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);\n    if (GsRGB <= 0.03928) G = GsRGB / 12.92;else G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);\n    if (BsRGB <= 0.03928) B = BsRGB / 12.92;else B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);\n    return 0.2126 * R + 0.7152 * G + 0.0722 * B;\n  },\n  setAlpha: function setAlpha(value) {\n    this._a = boundAlpha(value);\n    this._roundA = Math.round(100 * this._a) / 100;\n    return this;\n  },\n  toHsv: function toHsv() {\n    var hsv = rgbToHsv(this._r, this._g, this._b);\n    return {\n      h: hsv.h * 360,\n      s: hsv.s,\n      v: hsv.v,\n      a: this._a\n    };\n  },\n  toHsvString: function toHsvString() {\n    var hsv = rgbToHsv(this._r, this._g, this._b);\n    var h = Math.round(hsv.h * 360),\n      s = Math.round(hsv.s * 100),\n      v = Math.round(hsv.v * 100);\n    return this._a == 1 ? \"hsv(\" + h + \", \" + s + \"%, \" + v + \"%)\" : \"hsva(\" + h + \", \" + s + \"%, \" + v + \"%, \" + this._roundA + \")\";\n  },\n  toHsl: function toHsl() {\n    var hsl = rgbToHsl(this._r, this._g, this._b);\n    return {\n      h: hsl.h * 360,\n      s: hsl.s,\n      l: hsl.l,\n      a: this._a\n    };\n  },\n  toHslString: function toHslString() {\n    var hsl = rgbToHsl(this._r, this._g, this._b);\n    var h = Math.round(hsl.h * 360),\n      s = Math.round(hsl.s * 100),\n      l = Math.round(hsl.l * 100);\n    return this._a == 1 ? \"hsl(\" + h + \", \" + s + \"%, \" + l + \"%)\" : \"hsla(\" + h + \", \" + s + \"%, \" + l + \"%, \" + this._roundA + \")\";\n  },\n  toHex: function toHex(allow3Char) {\n    return rgbToHex(this._r, this._g, this._b, allow3Char);\n  },\n  toHexString: function toHexString(allow3Char) {\n    return \"#\" + this.toHex(allow3Char);\n  },\n  toHex8: function toHex8(allow4Char) {\n    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);\n  },\n  toHex8String: function toHex8String(allow4Char) {\n    return \"#\" + this.toHex8(allow4Char);\n  },\n  toRgb: function toRgb() {\n    return {\n      r: Math.round(this._r),\n      g: Math.round(this._g),\n      b: Math.round(this._b),\n      a: this._a\n    };\n  },\n  toRgbString: function toRgbString() {\n    return this._a == 1 ? \"rgb(\" + Math.round(this._r) + \", \" + Math.round(this._g) + \", \" + Math.round(this._b) + \")\" : \"rgba(\" + Math.round(this._r) + \", \" + Math.round(this._g) + \", \" + Math.round(this._b) + \", \" + this._roundA + \")\";\n  },\n  toPercentageRgb: function toPercentageRgb() {\n    return {\n      r: Math.round(bound01(this._r, 255) * 100) + \"%\",\n      g: Math.round(bound01(this._g, 255) * 100) + \"%\",\n      b: Math.round(bound01(this._b, 255) * 100) + \"%\",\n      a: this._a\n    };\n  },\n  toPercentageRgbString: function toPercentageRgbString() {\n    return this._a == 1 ? \"rgb(\" + Math.round(bound01(this._r, 255) * 100) + \"%, \" + Math.round(bound01(this._g, 255) * 100) + \"%, \" + Math.round(bound01(this._b, 255) * 100) + \"%)\" : \"rgba(\" + Math.round(bound01(this._r, 255) * 100) + \"%, \" + Math.round(bound01(this._g, 255) * 100) + \"%, \" + Math.round(bound01(this._b, 255) * 100) + \"%, \" + this._roundA + \")\";\n  },\n  toName: function toName() {\n    if (this._a === 0) {\n      return \"transparent\";\n    }\n    if (this._a < 1) {\n      return false;\n    }\n    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;\n  },\n  toFilter: function toFilter(secondColor) {\n    var hex8String = \"#\" + rgbaToArgbHex(this._r, this._g, this._b, this._a);\n    var secondHex8String = hex8String;\n    var gradientType = this._gradientType ? \"GradientType = 1, \" : \"\";\n    if (secondColor) {\n      var s = tinycolor(secondColor);\n      secondHex8String = \"#\" + rgbaToArgbHex(s._r, s._g, s._b, s._a);\n    }\n    return \"progid:DXImageTransform.Microsoft.gradient(\" + gradientType + \"startColorstr=\" + hex8String + \",endColorstr=\" + secondHex8String + \")\";\n  },\n  toString: function toString(format) {\n    var formatSet = !!format;\n    format = format || this._format;\n    var formattedString = false;\n    var hasAlpha = this._a < 1 && this._a >= 0;\n    var needsAlphaFormat = !formatSet && hasAlpha && (format === \"hex\" || format === \"hex6\" || format === \"hex3\" || format === \"hex4\" || format === \"hex8\" || format === \"name\");\n    if (needsAlphaFormat) {\n      // Special case for \"transparent\", all other non-alpha formats\n      // will return rgba when there is transparency.\n      if (format === \"name\" && this._a === 0) {\n        return this.toName();\n      }\n      return this.toRgbString();\n    }\n    if (format === \"rgb\") {\n      formattedString = this.toRgbString();\n    }\n    if (format === \"prgb\") {\n      formattedString = this.toPercentageRgbString();\n    }\n    if (format === \"hex\" || format === \"hex6\") {\n      formattedString = this.toHexString();\n    }\n    if (format === \"hex3\") {\n      formattedString = this.toHexString(true);\n    }\n    if (format === \"hex4\") {\n      formattedString = this.toHex8String(true);\n    }\n    if (format === \"hex8\") {\n      formattedString = this.toHex8String();\n    }\n    if (format === \"name\") {\n      formattedString = this.toName();\n    }\n    if (format === \"hsl\") {\n      formattedString = this.toHslString();\n    }\n    if (format === \"hsv\") {\n      formattedString = this.toHsvString();\n    }\n    return formattedString || this.toHexString();\n  },\n  clone: function clone() {\n    return tinycolor(this.toString());\n  },\n  _applyModification: function _applyModification(fn, args) {\n    var color = fn.apply(null, [this].concat([].slice.call(args)));\n    this._r = color._r;\n    this._g = color._g;\n    this._b = color._b;\n    this.setAlpha(color._a);\n    return this;\n  },\n  lighten: function lighten() {\n    return this._applyModification(_lighten, arguments);\n  },\n  brighten: function brighten() {\n    return this._applyModification(_brighten, arguments);\n  },\n  darken: function darken() {\n    return this._applyModification(_darken, arguments);\n  },\n  desaturate: function desaturate() {\n    return this._applyModification(_desaturate, arguments);\n  },\n  saturate: function saturate() {\n    return this._applyModification(_saturate, arguments);\n  },\n  greyscale: function greyscale() {\n    return this._applyModification(_greyscale, arguments);\n  },\n  spin: function spin() {\n    return this._applyModification(_spin, arguments);\n  },\n  _applyCombination: function _applyCombination(fn, args) {\n    return fn.apply(null, [this].concat([].slice.call(args)));\n  },\n  analogous: function analogous() {\n    return this._applyCombination(_analogous, arguments);\n  },\n  complement: function complement() {\n    return this._applyCombination(_complement, arguments);\n  },\n  monochromatic: function monochromatic() {\n    return this._applyCombination(_monochromatic, arguments);\n  },\n  splitcomplement: function splitcomplement() {\n    return this._applyCombination(_splitcomplement, arguments);\n  },\n  // Disabled until https://github.com/bgrins/TinyColor/issues/254\n  // polyad: function (number) {\n  //   return this._applyCombination(polyad, [number]);\n  // },\n  triad: function triad() {\n    return this._applyCombination(polyad, [3]);\n  },\n  tetrad: function tetrad() {\n    return this._applyCombination(polyad, [4]);\n  }\n};\n\n// If input is an object, force 1 into \"1.0\" to handle ratios properly\n// String input requires \"1.0\" as input, so 1 will be treated as 1\ntinycolor.fromRatio = function (color, opts) {\n  if (_typeof(color) == \"object\") {\n    var newColor = {};\n    for (var i in color) {\n      if (color.hasOwnProperty(i)) {\n        if (i === \"a\") {\n          newColor[i] = color[i];\n        } else {\n          newColor[i] = convertToPercentage(color[i]);\n        }\n      }\n    }\n    color = newColor;\n  }\n  return tinycolor(color, opts);\n};\n\n// Given a string or object, convert that input to RGB\n// Possible string inputs:\n//\n//     \"red\"\n//     \"#f00\" or \"f00\"\n//     \"#ff0000\" or \"ff0000\"\n//     \"#ff000000\" or \"ff000000\"\n//     \"rgb 255 0 0\" or \"rgb (255, 0, 0)\"\n//     \"rgb 1.0 0 0\" or \"rgb (1, 0, 0)\"\n//     \"rgba (255, 0, 0, 1)\" or \"rgba 255, 0, 0, 1\"\n//     \"rgba (1.0, 0, 0, 1)\" or \"rgba 1.0, 0, 0, 1\"\n//     \"hsl(0, 100%, 50%)\" or \"hsl 0 100% 50%\"\n//     \"hsla(0, 100%, 50%, 1)\" or \"hsla 0 100% 50%, 1\"\n//     \"hsv(0, 100%, 100%)\" or \"hsv 0 100% 100%\"\n//\nfunction inputToRGB(color) {\n  var rgb = {\n    r: 0,\n    g: 0,\n    b: 0\n  };\n  var a = 1;\n  var s = null;\n  var v = null;\n  var l = null;\n  var ok = false;\n  var format = false;\n  if (typeof color == \"string\") {\n    color = stringInputToObject(color);\n  }\n  if (_typeof(color) == \"object\") {\n    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {\n      rgb = rgbToRgb(color.r, color.g, color.b);\n      ok = true;\n      format = String(color.r).substr(-1) === \"%\" ? \"prgb\" : \"rgb\";\n    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {\n      s = convertToPercentage(color.s);\n      v = convertToPercentage(color.v);\n      rgb = hsvToRgb(color.h, s, v);\n      ok = true;\n      format = \"hsv\";\n    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {\n      s = convertToPercentage(color.s);\n      l = convertToPercentage(color.l);\n      rgb = hslToRgb(color.h, s, l);\n      ok = true;\n      format = \"hsl\";\n    }\n    if (color.hasOwnProperty(\"a\")) {\n      a = color.a;\n    }\n  }\n  a = boundAlpha(a);\n  return {\n    ok: ok,\n    format: color.format || format,\n    r: Math.min(255, Math.max(rgb.r, 0)),\n    g: Math.min(255, Math.max(rgb.g, 0)),\n    b: Math.min(255, Math.max(rgb.b, 0)),\n    a: a\n  };\n}\n\n// Conversion Functions\n// --------------------\n\n// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:\n// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>\n\n// `rgbToRgb`\n// Handle bounds / percentage checking to conform to CSS color spec\n// <http://www.w3.org/TR/css3-color/>\n// *Assumes:* r, g, b in [0, 255] or [0, 1]\n// *Returns:* { r, g, b } in [0, 255]\nfunction rgbToRgb(r, g, b) {\n  return {\n    r: bound01(r, 255) * 255,\n    g: bound01(g, 255) * 255,\n    b: bound01(b, 255) * 255\n  };\n}\n\n// `rgbToHsl`\n// Converts an RGB color value to HSL.\n// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]\n// *Returns:* { h, s, l } in [0,1]\nfunction rgbToHsl(r, g, b) {\n  r = bound01(r, 255);\n  g = bound01(g, 255);\n  b = bound01(b, 255);\n  var max = Math.max(r, g, b),\n    min = Math.min(r, g, b);\n  var h,\n    s,\n    l = (max + min) / 2;\n  if (max == min) {\n    h = s = 0; // achromatic\n  } else {\n    var d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0);\n        break;\n      case g:\n        h = (b - r) / d + 2;\n        break;\n      case b:\n        h = (r - g) / d + 4;\n        break;\n    }\n    h /= 6;\n  }\n  return {\n    h: h,\n    s: s,\n    l: l\n  };\n}\n\n// `hslToRgb`\n// Converts an HSL color value to RGB.\n// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]\n// *Returns:* { r, g, b } in the set [0, 255]\nfunction hslToRgb(h, s, l) {\n  var r, g, b;\n  h = bound01(h, 360);\n  s = bound01(s, 100);\n  l = bound01(l, 100);\n  function hue2rgb(p, q, t) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\n    if (t < 1 / 2) return q;\n    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n  }\n  if (s === 0) {\n    r = g = b = l; // achromatic\n  } else {\n    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    var p = 2 * l - q;\n    r = hue2rgb(p, q, h + 1 / 3);\n    g = hue2rgb(p, q, h);\n    b = hue2rgb(p, q, h - 1 / 3);\n  }\n  return {\n    r: r * 255,\n    g: g * 255,\n    b: b * 255\n  };\n}\n\n// `rgbToHsv`\n// Converts an RGB color value to HSV\n// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]\n// *Returns:* { h, s, v } in [0,1]\nfunction rgbToHsv(r, g, b) {\n  r = bound01(r, 255);\n  g = bound01(g, 255);\n  b = bound01(b, 255);\n  var max = Math.max(r, g, b),\n    min = Math.min(r, g, b);\n  var h,\n    s,\n    v = max;\n  var d = max - min;\n  s = max === 0 ? 0 : d / max;\n  if (max == min) {\n    h = 0; // achromatic\n  } else {\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0);\n        break;\n      case g:\n        h = (b - r) / d + 2;\n        break;\n      case b:\n        h = (r - g) / d + 4;\n        break;\n    }\n    h /= 6;\n  }\n  return {\n    h: h,\n    s: s,\n    v: v\n  };\n}\n\n// `hsvToRgb`\n// Converts an HSV color value to RGB.\n// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]\n// *Returns:* { r, g, b } in the set [0, 255]\nfunction hsvToRgb(h, s, v) {\n  h = bound01(h, 360) * 6;\n  s = bound01(s, 100);\n  v = bound01(v, 100);\n  var i = Math.floor(h),\n    f = h - i,\n    p = v * (1 - s),\n    q = v * (1 - f * s),\n    t = v * (1 - (1 - f) * s),\n    mod = i % 6,\n    r = [v, q, p, p, t, v][mod],\n    g = [t, v, v, q, p, p][mod],\n    b = [p, p, t, v, v, q][mod];\n  return {\n    r: r * 255,\n    g: g * 255,\n    b: b * 255\n  };\n}\n\n// `rgbToHex`\n// Converts an RGB color to hex\n// Assumes r, g, and b are contained in the set [0, 255]\n// Returns a 3 or 6 character hex\nfunction rgbToHex(r, g, b, allow3Char) {\n  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];\n\n  // Return a 3 character hex if possible\n  if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {\n    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);\n  }\n  return hex.join(\"\");\n}\n\n// `rgbaToHex`\n// Converts an RGBA color plus alpha transparency to hex\n// Assumes r, g, b are contained in the set [0, 255] and\n// a in [0, 1]. Returns a 4 or 8 character rgba hex\nfunction rgbaToHex(r, g, b, a, allow4Char) {\n  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a))];\n\n  // Return a 4 character hex if possible\n  if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {\n    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);\n  }\n  return hex.join(\"\");\n}\n\n// `rgbaToArgbHex`\n// Converts an RGBA color to an ARGB Hex8 string\n// Rarely used, but required for \"toFilter()\"\nfunction rgbaToArgbHex(r, g, b, a) {\n  var hex = [pad2(convertDecimalToHex(a)), pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];\n  return hex.join(\"\");\n}\n\n// `equals`\n// Can be called with any tinycolor input\ntinycolor.equals = function (color1, color2) {\n  if (!color1 || !color2) return false;\n  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();\n};\ntinycolor.random = function () {\n  return tinycolor.fromRatio({\n    r: Math.random(),\n    g: Math.random(),\n    b: Math.random()\n  });\n};\n\n// Modification Functions\n// ----------------------\n// Thanks to less.js for some of the basics here\n// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>\n\nfunction _desaturate(color, amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var hsl = tinycolor(color).toHsl();\n  hsl.s -= amount / 100;\n  hsl.s = clamp01(hsl.s);\n  return tinycolor(hsl);\n}\nfunction _saturate(color, amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var hsl = tinycolor(color).toHsl();\n  hsl.s += amount / 100;\n  hsl.s = clamp01(hsl.s);\n  return tinycolor(hsl);\n}\nfunction _greyscale(color) {\n  return tinycolor(color).desaturate(100);\n}\nfunction _lighten(color, amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var hsl = tinycolor(color).toHsl();\n  hsl.l += amount / 100;\n  hsl.l = clamp01(hsl.l);\n  return tinycolor(hsl);\n}\nfunction _brighten(color, amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var rgb = tinycolor(color).toRgb();\n  rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));\n  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));\n  rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));\n  return tinycolor(rgb);\n}\nfunction _darken(color, amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var hsl = tinycolor(color).toHsl();\n  hsl.l -= amount / 100;\n  hsl.l = clamp01(hsl.l);\n  return tinycolor(hsl);\n}\n\n// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.\n// Values outside of this range will be wrapped into this range.\nfunction _spin(color, amount) {\n  var hsl = tinycolor(color).toHsl();\n  var hue = (hsl.h + amount) % 360;\n  hsl.h = hue < 0 ? 360 + hue : hue;\n  return tinycolor(hsl);\n}\n\n// Combination Functions\n// ---------------------\n// Thanks to jQuery xColor for some of the ideas behind these\n// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>\n\nfunction _complement(color) {\n  var hsl = tinycolor(color).toHsl();\n  hsl.h = (hsl.h + 180) % 360;\n  return tinycolor(hsl);\n}\nfunction polyad(color, number) {\n  if (isNaN(number) || number <= 0) {\n    throw new Error(\"Argument to polyad must be a positive number\");\n  }\n  var hsl = tinycolor(color).toHsl();\n  var result = [tinycolor(color)];\n  var step = 360 / number;\n  for (var i = 1; i < number; i++) {\n    result.push(tinycolor({\n      h: (hsl.h + i * step) % 360,\n      s: hsl.s,\n      l: hsl.l\n    }));\n  }\n  return result;\n}\nfunction _splitcomplement(color) {\n  var hsl = tinycolor(color).toHsl();\n  var h = hsl.h;\n  return [tinycolor(color), tinycolor({\n    h: (h + 72) % 360,\n    s: hsl.s,\n    l: hsl.l\n  }), tinycolor({\n    h: (h + 216) % 360,\n    s: hsl.s,\n    l: hsl.l\n  })];\n}\nfunction _analogous(color, results, slices) {\n  results = results || 6;\n  slices = slices || 30;\n  var hsl = tinycolor(color).toHsl();\n  var part = 360 / slices;\n  var ret = [tinycolor(color)];\n  for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;) {\n    hsl.h = (hsl.h + part) % 360;\n    ret.push(tinycolor(hsl));\n  }\n  return ret;\n}\nfunction _monochromatic(color, results) {\n  results = results || 6;\n  var hsv = tinycolor(color).toHsv();\n  var h = hsv.h,\n    s = hsv.s,\n    v = hsv.v;\n  var ret = [];\n  var modification = 1 / results;\n  while (results--) {\n    ret.push(tinycolor({\n      h: h,\n      s: s,\n      v: v\n    }));\n    v = (v + modification) % 1;\n  }\n  return ret;\n}\n\n// Utility Functions\n// ---------------------\n\ntinycolor.mix = function (color1, color2, amount) {\n  amount = amount === 0 ? 0 : amount || 50;\n  var rgb1 = tinycolor(color1).toRgb();\n  var rgb2 = tinycolor(color2).toRgb();\n  var p = amount / 100;\n  var rgba = {\n    r: (rgb2.r - rgb1.r) * p + rgb1.r,\n    g: (rgb2.g - rgb1.g) * p + rgb1.g,\n    b: (rgb2.b - rgb1.b) * p + rgb1.b,\n    a: (rgb2.a - rgb1.a) * p + rgb1.a\n  };\n  return tinycolor(rgba);\n};\n\n// Readability Functions\n// ---------------------\n// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)\n\n// `contrast`\n// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)\ntinycolor.readability = function (color1, color2) {\n  var c1 = tinycolor(color1);\n  var c2 = tinycolor(color2);\n  return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);\n};\n\n// `isReadable`\n// Ensure that foreground and background color combinations meet WCAG2 guidelines.\n// The third argument is an optional Object.\n//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';\n//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.\n// If the entire object is absent, isReadable defaults to {level:\"AA\",size:\"small\"}.\n\n// *Example*\n//    tinycolor.isReadable(\"#000\", \"#111\") => false\n//    tinycolor.isReadable(\"#000\", \"#111\",{level:\"AA\",size:\"large\"}) => false\ntinycolor.isReadable = function (color1, color2, wcag2) {\n  var readability = tinycolor.readability(color1, color2);\n  var wcag2Parms, out;\n  out = false;\n  wcag2Parms = validateWCAG2Parms(wcag2);\n  switch (wcag2Parms.level + wcag2Parms.size) {\n    case \"AAsmall\":\n    case \"AAAlarge\":\n      out = readability >= 4.5;\n      break;\n    case \"AAlarge\":\n      out = readability >= 3;\n      break;\n    case \"AAAsmall\":\n      out = readability >= 7;\n      break;\n  }\n  return out;\n};\n\n// `mostReadable`\n// Given a base color and a list of possible foreground or background\n// colors for that base, returns the most readable color.\n// Optionally returns Black or White if the most readable color is unreadable.\n// *Example*\n//    tinycolor.mostReadable(tinycolor.mostReadable(\"#123\", [\"#124\", \"#125\"],{includeFallbackColors:false}).toHexString(); // \"#112255\"\n//    tinycolor.mostReadable(tinycolor.mostReadable(\"#123\", [\"#124\", \"#125\"],{includeFallbackColors:true}).toHexString();  // \"#ffffff\"\n//    tinycolor.mostReadable(\"#a8015a\", [\"#faf3f3\"],{includeFallbackColors:true,level:\"AAA\",size:\"large\"}).toHexString(); // \"#faf3f3\"\n//    tinycolor.mostReadable(\"#a8015a\", [\"#faf3f3\"],{includeFallbackColors:true,level:\"AAA\",size:\"small\"}).toHexString(); // \"#ffffff\"\ntinycolor.mostReadable = function (baseColor, colorList, args) {\n  var bestColor = null;\n  var bestScore = 0;\n  var readability;\n  var includeFallbackColors, level, size;\n  args = args || {};\n  includeFallbackColors = args.includeFallbackColors;\n  level = args.level;\n  size = args.size;\n  for (var i = 0; i < colorList.length; i++) {\n    readability = tinycolor.readability(baseColor, colorList[i]);\n    if (readability > bestScore) {\n      bestScore = readability;\n      bestColor = tinycolor(colorList[i]);\n    }\n  }\n  if (tinycolor.isReadable(baseColor, bestColor, {\n    level: level,\n    size: size\n  }) || !includeFallbackColors) {\n    return bestColor;\n  } else {\n    args.includeFallbackColors = false;\n    return tinycolor.mostReadable(baseColor, [\"#fff\", \"#000\"], args);\n  }\n};\n\n// Big List of Colors\n// ------------------\n// <https://www.w3.org/TR/css-color-4/#named-colors>\nvar names = tinycolor.names = {\n  aliceblue: \"f0f8ff\",\n  antiquewhite: \"faebd7\",\n  aqua: \"0ff\",\n  aquamarine: \"7fffd4\",\n  azure: \"f0ffff\",\n  beige: \"f5f5dc\",\n  bisque: \"ffe4c4\",\n  black: \"000\",\n  blanchedalmond: \"ffebcd\",\n  blue: \"00f\",\n  blueviolet: \"8a2be2\",\n  brown: \"a52a2a\",\n  burlywood: \"deb887\",\n  burntsienna: \"ea7e5d\",\n  cadetblue: \"5f9ea0\",\n  chartreuse: \"7fff00\",\n  chocolate: \"d2691e\",\n  coral: \"ff7f50\",\n  cornflowerblue: \"6495ed\",\n  cornsilk: \"fff8dc\",\n  crimson: \"dc143c\",\n  cyan: \"0ff\",\n  darkblue: \"00008b\",\n  darkcyan: \"008b8b\",\n  darkgoldenrod: \"b8860b\",\n  darkgray: \"a9a9a9\",\n  darkgreen: \"006400\",\n  darkgrey: \"a9a9a9\",\n  darkkhaki: \"bdb76b\",\n  darkmagenta: \"8b008b\",\n  darkolivegreen: \"556b2f\",\n  darkorange: \"ff8c00\",\n  darkorchid: \"9932cc\",\n  darkred: \"8b0000\",\n  darksalmon: \"e9967a\",\n  darkseagreen: \"8fbc8f\",\n  darkslateblue: \"483d8b\",\n  darkslategray: \"2f4f4f\",\n  darkslategrey: \"2f4f4f\",\n  darkturquoise: \"00ced1\",\n  darkviolet: \"9400d3\",\n  deeppink: \"ff1493\",\n  deepskyblue: \"00bfff\",\n  dimgray: \"696969\",\n  dimgrey: \"696969\",\n  dodgerblue: \"1e90ff\",\n  firebrick: \"b22222\",\n  floralwhite: \"fffaf0\",\n  forestgreen: \"228b22\",\n  fuchsia: \"f0f\",\n  gainsboro: \"dcdcdc\",\n  ghostwhite: \"f8f8ff\",\n  gold: \"ffd700\",\n  goldenrod: \"daa520\",\n  gray: \"808080\",\n  green: \"008000\",\n  greenyellow: \"adff2f\",\n  grey: \"808080\",\n  honeydew: \"f0fff0\",\n  hotpink: \"ff69b4\",\n  indianred: \"cd5c5c\",\n  indigo: \"4b0082\",\n  ivory: \"fffff0\",\n  khaki: \"f0e68c\",\n  lavender: \"e6e6fa\",\n  lavenderblush: \"fff0f5\",\n  lawngreen: \"7cfc00\",\n  lemonchiffon: \"fffacd\",\n  lightblue: \"add8e6\",\n  lightcoral: \"f08080\",\n  lightcyan: \"e0ffff\",\n  lightgoldenrodyellow: \"fafad2\",\n  lightgray: \"d3d3d3\",\n  lightgreen: \"90ee90\",\n  lightgrey: \"d3d3d3\",\n  lightpink: \"ffb6c1\",\n  lightsalmon: \"ffa07a\",\n  lightseagreen: \"20b2aa\",\n  lightskyblue: \"87cefa\",\n  lightslategray: \"789\",\n  lightslategrey: \"789\",\n  lightsteelblue: \"b0c4de\",\n  lightyellow: \"ffffe0\",\n  lime: \"0f0\",\n  limegreen: \"32cd32\",\n  linen: \"faf0e6\",\n  magenta: \"f0f\",\n  maroon: \"800000\",\n  mediumaquamarine: \"66cdaa\",\n  mediumblue: \"0000cd\",\n  mediumorchid: \"ba55d3\",\n  mediumpurple: \"9370db\",\n  mediumseagreen: \"3cb371\",\n  mediumslateblue: \"7b68ee\",\n  mediumspringgreen: \"00fa9a\",\n  mediumturquoise: \"48d1cc\",\n  mediumvioletred: \"c71585\",\n  midnightblue: \"191970\",\n  mintcream: \"f5fffa\",\n  mistyrose: \"ffe4e1\",\n  moccasin: \"ffe4b5\",\n  navajowhite: \"ffdead\",\n  navy: \"000080\",\n  oldlace: \"fdf5e6\",\n  olive: \"808000\",\n  olivedrab: \"6b8e23\",\n  orange: \"ffa500\",\n  orangered: \"ff4500\",\n  orchid: \"da70d6\",\n  palegoldenrod: \"eee8aa\",\n  palegreen: \"98fb98\",\n  paleturquoise: \"afeeee\",\n  palevioletred: \"db7093\",\n  papayawhip: \"ffefd5\",\n  peachpuff: \"ffdab9\",\n  peru: \"cd853f\",\n  pink: \"ffc0cb\",\n  plum: \"dda0dd\",\n  powderblue: \"b0e0e6\",\n  purple: \"800080\",\n  rebeccapurple: \"663399\",\n  red: \"f00\",\n  rosybrown: \"bc8f8f\",\n  royalblue: \"4169e1\",\n  saddlebrown: \"8b4513\",\n  salmon: \"fa8072\",\n  sandybrown: \"f4a460\",\n  seagreen: \"2e8b57\",\n  seashell: \"fff5ee\",\n  sienna: \"a0522d\",\n  silver: \"c0c0c0\",\n  skyblue: \"87ceeb\",\n  slateblue: \"6a5acd\",\n  slategray: \"708090\",\n  slategrey: \"708090\",\n  snow: \"fffafa\",\n  springgreen: \"00ff7f\",\n  steelblue: \"4682b4\",\n  tan: \"d2b48c\",\n  teal: \"008080\",\n  thistle: \"d8bfd8\",\n  tomato: \"ff6347\",\n  turquoise: \"40e0d0\",\n  violet: \"ee82ee\",\n  wheat: \"f5deb3\",\n  white: \"fff\",\n  whitesmoke: \"f5f5f5\",\n  yellow: \"ff0\",\n  yellowgreen: \"9acd32\"\n};\n\n// Make it easy to access colors via `hexNames[hex]`\nvar hexNames = tinycolor.hexNames = flip(names);\n\n// Utilities\n// ---------\n\n// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`\nfunction flip(o) {\n  var flipped = {};\n  for (var i in o) {\n    if (o.hasOwnProperty(i)) {\n      flipped[o[i]] = i;\n    }\n  }\n  return flipped;\n}\n\n// Return a valid alpha value [0,1] with all invalid values being set to 1\nfunction boundAlpha(a) {\n  a = parseFloat(a);\n  if (isNaN(a) || a < 0 || a > 1) {\n    a = 1;\n  }\n  return a;\n}\n\n// Take input from [0, n] and return it as [0, 1]\nfunction bound01(n, max) {\n  if (isOnePointZero(n)) n = \"100%\";\n  var processPercent = isPercentage(n);\n  n = Math.min(max, Math.max(0, parseFloat(n)));\n\n  // Automatically convert percentage into number\n  if (processPercent) {\n    n = parseInt(n * max, 10) / 100;\n  }\n\n  // Handle floating point rounding errors\n  if (Math.abs(n - max) < 0.000001) {\n    return 1;\n  }\n\n  // Convert into [0, 1] range if it isn't already\n  return n % max / parseFloat(max);\n}\n\n// Force a number between 0 and 1\nfunction clamp01(val) {\n  return Math.min(1, Math.max(0, val));\n}\n\n// Parse a base-16 hex value into a base-10 integer\nfunction parseIntFromHex(val) {\n  return parseInt(val, 16);\n}\n\n// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1\n// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>\nfunction isOnePointZero(n) {\n  return typeof n == \"string\" && n.indexOf(\".\") != -1 && parseFloat(n) === 1;\n}\n\n// Check to see if string passed in is a percentage\nfunction isPercentage(n) {\n  return typeof n === \"string\" && n.indexOf(\"%\") != -1;\n}\n\n// Force a hex value to have 2 characters\nfunction pad2(c) {\n  return c.length == 1 ? \"0\" + c : \"\" + c;\n}\n\n// Replace a decimal with it's percentage value\nfunction convertToPercentage(n) {\n  if (n <= 1) {\n    n = n * 100 + \"%\";\n  }\n  return n;\n}\n\n// Converts a decimal to a hex value\nfunction convertDecimalToHex(d) {\n  return Math.round(parseFloat(d) * 255).toString(16);\n}\n// Converts a hex value to a decimal\nfunction convertHexToDecimal(h) {\n  return parseIntFromHex(h) / 255;\n}\nvar matchers = function () {\n  // <http://www.w3.org/TR/css3-values/#integers>\n  var CSS_INTEGER = \"[-\\\\+]?\\\\d+%?\";\n\n  // <http://www.w3.org/TR/css3-values/#number-value>\n  var CSS_NUMBER = \"[-\\\\+]?\\\\d*\\\\.\\\\d+%?\";\n\n  // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.\n  var CSS_UNIT = \"(?:\" + CSS_NUMBER + \")|(?:\" + CSS_INTEGER + \")\";\n\n  // Actual matching.\n  // Parentheses and commas are optional, but not required.\n  // Whitespace can take the place of commas or opening paren\n  var PERMISSIVE_MATCH3 = \"[\\\\s|\\\\(]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")\\\\s*\\\\)?\";\n  var PERMISSIVE_MATCH4 = \"[\\\\s|\\\\(]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")\\\\s*\\\\)?\";\n  return {\n    CSS_UNIT: new RegExp(CSS_UNIT),\n    rgb: new RegExp(\"rgb\" + PERMISSIVE_MATCH3),\n    rgba: new RegExp(\"rgba\" + PERMISSIVE_MATCH4),\n    hsl: new RegExp(\"hsl\" + PERMISSIVE_MATCH3),\n    hsla: new RegExp(\"hsla\" + PERMISSIVE_MATCH4),\n    hsv: new RegExp(\"hsv\" + PERMISSIVE_MATCH3),\n    hsva: new RegExp(\"hsva\" + PERMISSIVE_MATCH4),\n    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,\n    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/\n  };\n}();\n\n// `isValidCSSUnit`\n// Take in a single string / number and check to see if it looks like a CSS unit\n// (see `matchers` above for definition).\nfunction isValidCSSUnit(color) {\n  return !!matchers.CSS_UNIT.exec(color);\n}\n\n// `stringInputToObject`\n// Permissive string parsing.  Take in a number of formats, and output an object\n// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`\nfunction stringInputToObject(color) {\n  color = color.replace(trimLeft, \"\").replace(trimRight, \"\").toLowerCase();\n  var named = false;\n  if (names[color]) {\n    color = names[color];\n    named = true;\n  } else if (color == \"transparent\") {\n    return {\n      r: 0,\n      g: 0,\n      b: 0,\n      a: 0,\n      format: \"name\"\n    };\n  }\n\n  // Try to match string input using regular expressions.\n  // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]\n  // Just return an object and let the conversion functions handle that.\n  // This way the result will be the same whether the tinycolor is initialized with string or object.\n  var match;\n  if (match = matchers.rgb.exec(color)) {\n    return {\n      r: match[1],\n      g: match[2],\n      b: match[3]\n    };\n  }\n  if (match = matchers.rgba.exec(color)) {\n    return {\n      r: match[1],\n      g: match[2],\n      b: match[3],\n      a: match[4]\n    };\n  }\n  if (match = matchers.hsl.exec(color)) {\n    return {\n      h: match[1],\n      s: match[2],\n      l: match[3]\n    };\n  }\n  if (match = matchers.hsla.exec(color)) {\n    return {\n      h: match[1],\n      s: match[2],\n      l: match[3],\n      a: match[4]\n    };\n  }\n  if (match = matchers.hsv.exec(color)) {\n    return {\n      h: match[1],\n      s: match[2],\n      v: match[3]\n    };\n  }\n  if (match = matchers.hsva.exec(color)) {\n    return {\n      h: match[1],\n      s: match[2],\n      v: match[3],\n      a: match[4]\n    };\n  }\n  if (match = matchers.hex8.exec(color)) {\n    return {\n      r: parseIntFromHex(match[1]),\n      g: parseIntFromHex(match[2]),\n      b: parseIntFromHex(match[3]),\n      a: convertHexToDecimal(match[4]),\n      format: named ? \"name\" : \"hex8\"\n    };\n  }\n  if (match = matchers.hex6.exec(color)) {\n    return {\n      r: parseIntFromHex(match[1]),\n      g: parseIntFromHex(match[2]),\n      b: parseIntFromHex(match[3]),\n      format: named ? \"name\" : \"hex\"\n    };\n  }\n  if (match = matchers.hex4.exec(color)) {\n    return {\n      r: parseIntFromHex(match[1] + \"\" + match[1]),\n      g: parseIntFromHex(match[2] + \"\" + match[2]),\n      b: parseIntFromHex(match[3] + \"\" + match[3]),\n      a: convertHexToDecimal(match[4] + \"\" + match[4]),\n      format: named ? \"name\" : \"hex8\"\n    };\n  }\n  if (match = matchers.hex3.exec(color)) {\n    return {\n      r: parseIntFromHex(match[1] + \"\" + match[1]),\n      g: parseIntFromHex(match[2] + \"\" + match[2]),\n      b: parseIntFromHex(match[3] + \"\" + match[3]),\n      format: named ? \"name\" : \"hex\"\n    };\n  }\n  return false;\n}\nfunction validateWCAG2Parms(parms) {\n  // return valid WCAG2 parms for isReadable.\n  // If input parms are invalid, return {\"level\":\"AA\", \"size\":\"small\"}\n  var level, size;\n  parms = parms || {\n    level: \"AA\",\n    size: \"small\"\n  };\n  level = (parms.level || \"AA\").toUpperCase();\n  size = (parms.size || \"small\").toLowerCase();\n  if (level !== \"AA\" && level !== \"AAA\") {\n    level = \"AA\";\n  }\n  if (size !== \"small\" && size !== \"large\") {\n    size = \"small\";\n  }\n  return {\n    level: level,\n    size: size\n  };\n}\n\nexport { tinycolor as default };\n","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.WorkBoots = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n\n},{}],2:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],3:[function(require,module,exports){\n(function (process,global){(function (){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WorkBoots = exports.Socks = void 0;\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = \"function\" == typeof Symbol ? Symbol : {}, n = r.iterator || \"@@iterator\", o = r.toStringTag || \"@@toStringTag\"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, \"_invoke\", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError(\"Generator is already running\"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = \"next\"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i[\"return\"]) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine2(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, \"Generator\"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, \"toString\", function () { return \"[object Generator]\"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, \"\", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2)); }, _regeneratorDefine2(e, r, n, t); }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, \"default\": e }; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t3 in e) \"default\" !== _t3 && {}.hasOwnProperty.call(e, _t3) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t3)) && (i.get || i.set) ? o(f, _t3, i) : f[_t3] = e[_t3]); return f; })(e, t); }\n/**\n * Universal entry point for work-boots\n * Compatible with Browserify, Node.js, and ES modules\n */\n\n// Detect environment\nvar isNode = typeof process !== 'undefined' && process.versions && process.versions.node;\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n\n// Universal require/import function\nfunction universalRequire(moduleName) {\n  if (isNode) {\n    // In Node.js, use dynamic import\n    return function (specifier) {\n      return new Promise(function (r) {\n        return r(\"\".concat(specifier));\n      }).then(function (s) {\n        return _interopRequireWildcard(require(s));\n      });\n    }(moduleName);\n  } else {\n    // In browser, assume it's available globally or bundled\n    return Promise.resolve({\n      \"default\": global[moduleName]\n    });\n  }\n}\n\n// Enhanced WorkBoots with Browserify compatibility\nvar WorkBoots = exports.WorkBoots = /*#__PURE__*/function () {\n  function WorkBoots(_ref) {\n    var _this = this;\n    var socksFile = _ref.socksFile,\n      _ref$instantiateWorke = _ref.instantiateWorker,\n      instantiateWorker = _ref$instantiateWorke === void 0 ? null : _ref$instantiateWorke;\n    _classCallCheck(this, WorkBoots);\n    if (socksFile === undefined) {\n      this.readyPromise = Promise.reject(new Error('no socksFile defined!'));\n      return;\n    }\n\n    // Determine worker support based on environment\n    this.supportsWorker = this.detectWorkerSupport();\n    this.receivedBeforeReady = [];\n    this.isReady = false;\n\n    // Create default worker instantiation function based on environment\n    if (!instantiateWorker) {\n      instantiateWorker = this.createDefaultWorkerFactory();\n    }\n    this.readyPromise = new Promise(function (resolve) {\n      var velcroAndLaces = function velcroAndLaces(message) {\n        if ((message === null || message === void 0 ? void 0 : message.data) === 'socks loaded') {\n          resolve(_this);\n        } else {\n          for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            rest[_key - 1] = arguments[_key];\n          }\n          console.log('received message before socks.ready() was called, ' + JSON.stringify([message].concat(rest)));\n          _this.receivedBeforeReady.push([message].concat(rest));\n        }\n      };\n      _this.onMessage(velcroAndLaces);\n      if (_this.supportsWorker) {\n        try {\n          _this.worker = instantiateWorker(socksFile);\n          _this.supportsWorker = true;\n          _this.isReady = true;\n        } catch (e) {\n          _this.worker = undefined;\n          _this.supportsWorker = false;\n          console.log('background worker not supported, switching to shorter socks (main thread eval).', e);\n        }\n      }\n      if (!_this.supportsWorker) {\n        _this.supportsWorker = false;\n        // Handle import errors gracefully with Browserify compatibility\n        _this.loadSocksFile(socksFile).then(function (_ref2) {\n          var socks = _ref2.socks;\n          _this.socks = socks;\n          _this.socks.enterBoots(_this);\n          _this.isReady = true;\n          resolve(_this);\n        })[\"catch\"](function (error) {\n          console.log('Failed to import socks file, creating mock socks:', error.message);\n          // Create a mock socks for testing\n          _this.socks = {\n            enterBoots: function enterBoots(boots) {\n              _this.boots = boots;\n            },\n            onMessageLocal: function onMessageLocal(message) {\n              if (_this.onMessageCallback) {\n                _this.onMessageCallback({\n                  data: message.data\n                });\n              }\n            },\n            terminate: function terminate() {}\n          };\n          _this.socks.enterBoots(_this);\n          _this.isReady = true;\n          resolve(_this);\n        });\n      }\n    });\n  }\n\n  // Browserify-compatible module loading\n  return _createClass(WorkBoots, [{\n    key: \"loadSocksFile\",\n    value: function () {\n      var _loadSocksFile = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(socksFile) {\n        var _t;\n        return _regenerator().w(function (_context) {\n          while (1) switch (_context.p = _context.n) {\n            case 0:\n              _context.p = 0;\n              _context.n = 1;\n              return function (specifier) {\n                return new Promise(function (r) {\n                  return r(\"\".concat(specifier));\n                }).then(function (s) {\n                  return _interopRequireWildcard(require(s));\n                });\n              }(socksFile);\n            case 1:\n              return _context.a(2, _context.v);\n            case 2:\n              _context.p = 2;\n              _t = _context.v;\n              if (!(typeof require !== 'undefined')) {\n                _context.n = 3;\n                break;\n              }\n              return _context.a(2, require(socksFile));\n            case 3:\n              throw _t;\n            case 4:\n              return _context.a(2);\n          }\n        }, _callee, null, [[0, 2]]);\n      }));\n      function loadSocksFile(_x) {\n        return _loadSocksFile.apply(this, arguments);\n      }\n      return loadSocksFile;\n    }()\n  }, {\n    key: \"detectWorkerSupport\",\n    value: function detectWorkerSupport() {\n      if (isBrowser) {\n        return typeof Worker !== 'undefined';\n      } else if (isNode) {\n        try {\n          // Use dynamic import for worker_threads in ES modules\n          return true; // We'll check this in createDefaultWorkerFactory\n        } catch (e) {\n          return false;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"createDefaultWorkerFactory\",\n    value: function createDefaultWorkerFactory() {\n      if (isBrowser) {\n        return function (socksFile) {\n          return new Worker(socksFile);\n        };\n      } else if (isNode) {\n        return /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(socksFile) {\n            var _yield$import, _Worker, _t2;\n            return _regenerator().w(function (_context2) {\n              while (1) switch (_context2.p = _context2.n) {\n                case 0:\n                  _context2.p = 0;\n                  _context2.n = 1;\n                  return Promise.resolve().then(function () {\n                    return _interopRequireWildcard(require('worker_threads'));\n                  });\n                case 1:\n                  _yield$import = _context2.v;\n                  _Worker = _yield$import.Worker;\n                  return _context2.a(2, new _Worker(socksFile, {\n                    type: 'module'\n                  }));\n                case 2:\n                  _context2.p = 2;\n                  _t2 = _context2.v;\n                  throw new Error('Worker threads not available');\n                case 3:\n                  return _context2.a(2);\n              }\n            }, _callee2, null, [[0, 2]]);\n          }));\n          return function (_x2) {\n            return _ref3.apply(this, arguments);\n          };\n        }();\n      }\n      return function () {\n        throw new Error('No worker support available');\n      };\n    }\n  }, {\n    key: \"ready\",\n    value: function ready() {\n      return this.readyPromise;\n    }\n  }, {\n    key: \"postMessage\",\n    value: function postMessage(data) {\n      var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var transfer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      if (!this.isReady) {\n        this.onMessageCallback(data, origin, transfer);\n        return;\n      }\n      var message = 'data' in data ? data : {\n        data: data\n      };\n      console.log(\"supports worker: \".concat(this.supportsWorker));\n      if (this.supportsWorker) {\n        // Handle different worker types\n        if (isBrowser) {\n          var _this$worker;\n          (_this$worker = this.worker).postMessage.apply(_this$worker, _toConsumableArray([data, transfer.length > 0 ? transfer : undefined].filter(function (arg) {\n            return !!arg;\n          })));\n        } else if (isNode) {\n          this.worker.postMessage(data, transfer);\n        }\n      } else {\n        this.socks.onMessageLocal(message, transfer);\n      }\n    }\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(callback) {\n      var _this2 = this;\n      this.onMessageCallback = callback;\n      if (this.worker) {\n        if (isBrowser) {\n          this.worker.onmessage = callback;\n        } else if (isNode) {\n          // Check if worker has 'on' method (Node.js worker threads)\n          if (typeof this.worker.on === 'function') {\n            this.worker.on('message', callback);\n          } else {\n            // Fallback for mock workers or other implementations\n            this.worker.onmessage = callback;\n          }\n        }\n      }\n      if (this.receivedBeforeReady.length) {\n        console.log('messages received before socks loaded now replaying (not necessarily a problem, but loading out of order):');\n        this.receivedBeforeReady.forEach(function (m) {\n          return _this2.onMessageCallback && _this2.onMessageCallback.apply(_this2, _toConsumableArray(m));\n        });\n      }\n    }\n  }, {\n    key: \"onMessageLocal\",\n    value: function onMessageLocal(data, origin) {\n      var transfer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      console.log(\"sending local message that would have been to origin \".concat(origin));\n      if ((transfer === null || transfer === void 0 ? void 0 : transfer.length) > 0) {\n        console.log(\"transfer ignored for \".concat(transfer.length, \" transfer references\"));\n      }\n      console.log(\"onMessageCallback \".concat(this.onMessageCallback));\n      if (this.onMessageCallback) {\n        this.onMessageCallback({\n          data: data\n        });\n      } else {\n        throw new Error('onMessageLocal should not be called without onMessageCallback defined');\n      }\n    }\n  }, {\n    key: \"terminate\",\n    value: function terminate() {\n      if (this.supportsWorker) {\n        if (isBrowser) {\n          this.worker.terminate();\n        } else if (isNode) {\n          this.worker.terminate();\n        }\n      } else {\n        this.socks.terminate();\n      }\n    }\n  }]);\n}(); // Enhanced Socks with Browserify compatibility\nvar Socks = exports.Socks = /*#__PURE__*/function () {\n  function Socks() {\n    var self = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    _classCallCheck(this, Socks);\n    this.self = self;\n    this.postsBeforeReady = [];\n    this.isReady = false;\n    this.sentReadyMessage = false;\n  }\n  return _createClass(Socks, [{\n    key: \"ready\",\n    value: function ready() {\n      if (this.isWorkerSupported()) {\n        this.postMessage(\"socks loaded\");\n        this.sentReadyMessage = true;\n      } else {\n        if (this.boots) {\n          this.boots.onMessageLocal(\"socks loaded\");\n          this.sentReadyMessage = true;\n        }\n      }\n      this.isReady = true;\n      this.processReadyMessages();\n    }\n  }, {\n    key: \"processReadyMessages\",\n    value: function processReadyMessages() {\n      var _this3 = this;\n      if (this.sentReadyMessage) {\n        this.postsBeforeReady.forEach(function (args) {\n          return _this3.postMessage.apply(_this3, _toConsumableArray(args));\n        });\n        this.postsBeforeReady = [];\n      }\n    }\n  }, {\n    key: \"enterBoots\",\n    value: function enterBoots(boots) {\n      var _this$self;\n      this.boots = boots;\n      if (this.isReady && !this.sentReadyMessage) {\n        this.ready();\n      }\n      // if enter boots is called, we don't have background worker support\n      //  so set self to undefined as we want to keep this entirely local.\n      if ((_this$self = this.self) !== null && _this$self !== void 0 && _this$self.onmessage) {\n        this.onMessageCallback = this.self.onmessage;\n      }\n      this.self = undefined;\n    }\n  }, {\n    key: \"postMessage\",\n    value: function postMessage(data, origin /* = window?.document?.location?.origin*/) {\n      var transfer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      if (!this.isReady) {\n        this.postsBeforeReady.push([data, origin, transfer]);\n        return;\n      }\n      var message = _typeof(data) === 'object' && 'data' in data ? data : {\n        data: data\n      };\n      if (this.isWorkerSupported()) {\n        if (isBrowser) {\n          var _this$self2;\n          (_this$self2 = this.self).postMessage.apply(_this$self2, _toConsumableArray([data, origin, transfer.length > 0 ? transfer : undefined].filter(function (arg) {\n            return !!arg;\n          })));\n        } else if (isNode) {\n          this.self.postMessage(data, transfer);\n        }\n      } else {\n        this.boots.onMessageLocal(message, origin, transfer);\n      }\n    }\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(callback) {\n      console.log('support ' + this.isWorkerSupported());\n      if (this.isWorkerSupported()) {\n        if (isBrowser) {\n          this.self.onmessage = callback;\n        } else if (isNode) {\n          // Check if self has 'on' method (Node.js worker threads)\n          if (typeof this.self.on === 'function') {\n            this.self.on('message', callback);\n          } else {\n            // Fallback for mock workers or other implementations\n            this.self.onmessage = callback;\n          }\n        }\n      } else {\n        this.onMessageCallback = callback;\n      }\n    }\n  }, {\n    key: \"onMessageLocal\",\n    value: function onMessageLocal(data, origin) {\n      var transfer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      console.log(\"sending local message that would have been to origin \".concat(origin));\n      if ((transfer === null || transfer === void 0 ? void 0 : transfer.length) > 0) {\n        console.log(\"transfer ignored for \".concat(transfer.length, \" transfer references\"));\n      }\n      console.log(this.onMessageCallback);\n      if (this.onMessageCallback) {\n        this.onMessageCallback(data);\n      } else {\n        throw new Error('onMessageLocal should not be called without onMessageCallback defined');\n      }\n    }\n  }, {\n    key: \"terminate\",\n    value: function terminate() {\n      var _this$self3, _this$self4;\n      this.terminateCallback && this.terminateCallback();\n      if (typeof ((_this$self3 = this.self) === null || _this$self3 === void 0 ? void 0 : _this$self3.terminate) === 'function') (_this$self4 = this.self) === null || _this$self4 === void 0 || _this$self4.terminate();\n    }\n  }, {\n    key: \"onTerminate\",\n    value: function onTerminate(callback) {\n      // this is only called when we don't support service workers... beware1!!!1\n      this.terminateCallback = callback;\n    }\n  }, {\n    key: \"isWorkerSupported\",\n    value: function isWorkerSupported() {\n      if (isBrowser) {\n        return typeof Worker !== 'undefined' && !!this.self;\n      } else if (isNode) {\n        return !!this.self;\n      }\n      return false;\n    }\n  }]);\n}(); // Universal exports for all environments\n// CommonJS compatibility for Browserify\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = {\n    WorkBoots: WorkBoots,\n    Socks: Socks\n  };\n}\n\n// AMD compatibility\nif (typeof define === 'function' && define.amd) {\n  define([], function () {\n    return {\n      WorkBoots: WorkBoots,\n      Socks: Socks\n    };\n  });\n}\n\n// Global compatibility for browser\nif (typeof window !== 'undefined') {\n  window.WorkBoots = WorkBoots;\n  window.Socks = Socks;\n}\n\n}).call(this)}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"_process\":2,\"worker_threads\":1}]},{},[3])(3)\n});\n","'use strict'\n\n/**\n  https://github.com/NathanEpstein/clusters\n  License: MIT\n*/\n\nexport const clusterMaker = {\n\n  data: getterSetter([], function(arrayOfArrays) {\n    var n = arrayOfArrays[0].length;\n    return (arrayOfArrays.map(function(array) {\n      return array.length == n;\n    }).reduce(function(boolA, boolB) { return (boolA & boolB) }, true));\n  }),\n\n  clusters: function() {\n    var pointsAndCentroids = kmeans(this.data(), {k: this.k(), iterations: this.iterations() });\n    var points = pointsAndCentroids.points;\n    var centroids = pointsAndCentroids.centroids;\n//sequencer add\n    return centroids.map(function(centroid) {\n      //sequencer add\n      return {\n        centroid: centroid.location(),\n        points: points.filter(function(point) { return point.label() == centroid.label() }).map(function(point) { return point.location() }),\n      };\n    });\n  },\n\n  k: getterSetter(undefined, function(value) { return ((value % 1 == 0) & (value > 0)) }),\n\n  iterations: getterSetter(Math.pow(10, 3), function(value) { return ((value % 1 == 0) & (value > 0)) }),\n\n};\n\nexport function kmeans(sequencer, data, config) {\n  //sequencer add, 0\n  // default k\n  let k, iterations, points, centroids\n  sequencer.add(() => {\n    k = config.k || Math.round(Math.sqrt(data.length / 2));\n    iterations = config.iterations;\n  }, data, 0)\n\n  //sequencer add, 1\n  // initialize point objects with data\n  sequencer.add(() => {\n    points = data.map(function(vector) { return new Point(vector) });\n  }, points, 1)\n\n  //sequencer add, 1\n  // intialize centroids randomly\n  sequencer.add(() => {\n    centroids = []\n    for (var i = 0; i < k; i++) {\n      centroids.push(new Centroid(points[i % points.length].location(), i));\n    };\n  }, points, 1)\n\n  //sequencer add, 1\n  // update labels and centroid locations until convergence\n  //sequencer.add(() => {\n  //}, points, 2)\n\n  //because this was a prohibitively expensive call, we'll break this for loop up into a schedule of sequences\n  // iterate should be used for anything expected to require more than 37000 operations\n  sequencer.iterate(0, iter => iter < iterations, iter => iter+1,\n    iter => {\n      //sequencer insert, 3, maybe 2? reverse loop for sequence eval?\n      //nested continuation might be better here?\n      // otherwise we'll have to lift a variable in each iteration of the loop, and that could get relatively expensive\n      // whereas nesting the continuation would mean that variables for each point / centroid won't get created until the current sequence is evaluated\n      points.forEach(function(point) { point.updateLabel(centroids) });\n      centroids.forEach(function(centroid) { centroid.updateLocation(points) });\n    }, points, 1)\n\n  //sequencer add, 0\n  // return points and centroids\n  sequencer.add(() => sequencer.resolve({\n    points: points,\n    centroids: centroids\n  }), [], 0)\n\n  return sequencer;\n};\n\n// objects\nfunction Point(location) {\n  var self = this;\n  this.location = getterSetter(location);\n  this.label = getterSetter();\n  this.updateLabel = function(centroids) {\n    var distancesSquared = centroids.map(function(centroid) {\n      return sumOfSquareDiffs(self.location(), centroid.location());\n    });\n    self.label(mindex(distancesSquared));\n  };\n};\n\nfunction Centroid(initialLocation, label) {\n  var self = this;\n  this.location = getterSetter(initialLocation);\n  this.label = getterSetter(label);\n  this.updateLocation = function(points) {\n    var pointsWithThisCentroid = points.filter(function(point) { return point.label() == self.label() });\n    if (pointsWithThisCentroid.length > 0) self.location(averageLocation(pointsWithThisCentroid));\n  };\n};\n\n// convenience functions\nfunction getterSetter(initialValue, validator) {\n  var thingToGetSet = initialValue;\n  var isValid = validator || function(val) { return true };\n  return function(newValue) {\n    if (typeof newValue === 'undefined') return thingToGetSet;\n    if (isValid(newValue)) thingToGetSet = newValue;\n  };\n};\n\nfunction sumOfSquareDiffs(oneVector, anotherVector) {\n  var squareDiffs = oneVector.map(function(component, i) {\n    return Math.pow(component - anotherVector[i], 2);\n  });\n  return squareDiffs.reduce(function(a, b) { return a + b }, 0);\n};\n\nfunction mindex(array) {\n  var min = array.reduce(function(a, b) {\n    return Math.min(a, b);\n  });\n  return array.indexOf(min);\n};\n\nfunction sumVectors(a, b) {\n  return a.map(function(val, i) { return val + b[i] });\n};\n\nfunction averageLocation(points) {\n  var zeroVector = points[0].location().map(function() { return 0 });\n  var locations = points.map(function(point) { return point.location() });\n  var vectorSum = locations.reduce(function(a, b) { return sumVectors(a, b) }, zeroVector);\n  return vectorSum.map(function(val) { return val / points.length });\n};\n\nfunction __kmeans(data, config) {\n  // default k\n  var k = config.k || Math.round(Math.sqrt(data.length / 2));\n  var iterations = config.iterations;\n\n  // initialize point objects with data\n  var points = data.map(function(vector) { return new Point(vector) });\n\n  // intialize centroids randomly\n  var centroids = [];\n  for (var i = 0; i < k; i++) {\n    centroids.push(new Centroid(points[i % points.length].location(), i));\n  };\n\n  // update labels and centroid locations until convergence\n  for (var iter = 0; iter < iterations; iter++) {\n    points.forEach(function(point) { point.updateLabel(centroids) });\n    centroids.forEach(function(centroid) { centroid.updateLocation(points) });\n  };\n\n  // return points and centroids\n  return {\n    points: points,\n    centroids: centroids\n  };\n\n};\n","/**\nA light native alternative to underscore, as the fitbit compiler was not able to handle the callstack size :(\nMany of the solutions are pulled from https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_flatten\nAlternatively I may pull directly from lodash or underscore\nLicenses are inherited from underscore including MIT and Apache 2.0\n*/\nconst makeSelect = (comparator) => (a, b) => comparator(a, b) ? a : b\nconst pluck = (list, name) => list.map(x => x[name])\n\nconst first = (list, valueOrPredicate) => {\n  let i = 0\n\n  if (typeof valueOrPredicate !== 'function') {\n      let val = valueOrPredicate\n      valueOrPredicate = (newVal) => newVal === val\n  }\n  while (i < list.length && !valueOrPredicate(list[i])) i++\n  return i < list.length ? list[i] : undefined\n}\n\nconst all = (list, valueOrPredicate) => {\n  let i = 0\n  if (typeof valueOrPredicate !== 'function') {\n      let val = valueOrPredicate\n      valueOrPredicate = (newVal) => newVal === val\n  }\n  while (i < list.length && valueOrPredicate(list[i])) i++\n  return i == list.length\n}\n\n//from underscore.js\n// Returns whether an object has a given set of `key:value` pairs.\nconst isMatch = function(object, attrs) {\n  let keys = Object.keys(attrs), length = keys.length;\n  if (object == null) return !length;\n  let obj = Object(object);\n  for (let i = 0; i < length; i++) {\n    let key = keys[i];\n    if (attrs[key] !== obj[key] || !(key in obj)) return false;\n  }\n  return true;\n}\n\n//from underscore.js\n// accepts an array to retrieve the properties in an object recursively\nconst deepGet = function(obj, path) {\n  const length = path.length;\n  for (let i = 0; i < length; i++) {\n    if (obj == null) return void 0;\n    obj = obj[path[i]];\n  }\n  return length ? obj : void 0;\n}\n\n//from underscore.js\n// A helper function to wrap callbacks appropriately, and safeguard against empty callbacks etc\nconst cb = function(value, context, argCount) {\n    if (value == null || value == undefined) return (v) => v;\n    if (typeof value === 'function') return value.bind(context)\n    if (typeof value === 'object' && !Array.isArray(value)) return v => isMatch(v, value);\n    //at this point we're only left with a string or a number, so we'll retrieve either an index or a property\n    return Array.isArray(value) ? v => deepGet(v, value) : v => v[value];\n}\n\nexport const _ = {\n    uniq(list) { return [...new Set(list)] },\n    pairs(object) { return Object.entries(object) },\n    first: first,\n    keys: Object.keys,\n    sum(list) { return list.reduce(function(memo, num){ return memo + num; }, 0) },\n    flatten(list) { return list.reduce( (a, b) => a.concat(b), []) },\n    minBy(collection, key) {\n      // slower because need to create a lambda function for each call...\n      const select = (a, b) => a[key] <= b[key] ? a : b\n      return collection.reduce(select, {})\n    },\n    maxBy(collection, key) {\n      // slower because need to create a lambda function for each call...\n      const select = (a, b) => a[key] >= b[key] ? a : b\n      return collection.reduce(select, {})\n    },\n    min(collection, iteratee) {\n      let comparitor = makeSelect((a, b) => a <= (iteratee !== undefined ? iteratee(b) : b))\n      let initial = collection.length > 0 ? collection[0] : undefined\n      if (iteratee !== undefined) initial = iteratee(initial)\n      return collection.reduce(comparitor, initial)\n    },\n    max(collection, iteratee) {\n      let comparitor = makeSelect((a, b) => a >= (iteratee !== undefined ? iteratee(b) : b))\n      let initial = collection.length > 0 ? collection[0] : undefined\n      if (iteratee !== undefined) initial = iteratee(initial)\n      return collection.reduce(comparitor, initial)\n    },\n    pluck: pluck,\n    sortby(obj, iteratee, context) {\n      //sourced and modified directly from underscore\n      var index = 0;\n      iteratee = cb(iteratee, context);\n      return pluck(obj.map(function(value, key, list) {\n        return {\n          value: value,\n          index: index++,\n          criteria: iteratee(value, key, list)\n        };\n      }).sort(function(left, right) {\n        var a = left.criteria;\n        var b = right.criteria;\n        if (a !== b) {\n          if (a > b || a === void 0) return 1;\n          if (a < b || b === void 0) return -1;\n        }\n        return left.index - right.index;\n      }), 'value');\n    },\n    any(list, valueOrPredicate) {\n      return first(list, valueOrPredicate) !== undefined\n    },\n    all: all\n  }\n\nconst test = () => {\n  let fails = []\n\n  if (_.min([1,2,3,4]) != 1) fails.push('min')\n  if (_.max([1,2,3,4]) != 4) fails.push('max')\n  let tosort = [{value:2}, {value:1}, {value:3}, {value:4}, {value:-1}]\n  if (_.sortby(tosort, 'value')[0].value != -1) fails.push('sortby:string prop')\n  if (_.sortby(tosort, v => v.value)[0].value != -1) fails.push('sortby:function')\n  if (!_.any([1,2,3,4,5,6,'bloop'], v => v == 'bloop')) fails.push('any:predicate')\n  if (!_.any([1,2,3,4,5,6,'bloop'], 'bloop')) fails.push('any:value')\n  if (_.pluck([{a: 'youch', b: 'b'}, {a: 'stop that', b: 'b'}, {a: 'quit it', b: 'b'}], 'a').join(' ') != 'youch stop that quit it') fails.push('pluck')\n  if (!isMatch(_.minBy(tosort, 'value'), {value:-1})) fails.push('minBy')\n  if (!isMatch(_.maxBy(tosort, 'value'), {value:4})) fails.push('maxBy')\n  if (!isMatch(_.keys({a:'a', b:'b', c:'c'}), ['a', 'b', 'c'])) fails.push('keys')\n  if (!isMatch(_.flatten(_.pairs({a:'a', b:'b', c:'c'})), ['a', 'a', 'b', 'b', 'c', 'c'])) fails.push('pairs')\n  if (!isMatch(_.uniq([1,1,1,1,1,2,2,2,2,2,2,3,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5]), [1,2,3,4,5])) fails.push('uniq')\n  if (_.sum([1,2,3,4]) != 10) fails.push('sum')\n  if (!isMatch(_.flatten([1,[2,3,4],5]), [1,2,3,4,5])) fails.push('flatten')\n  if (!_.all([1,2,3,4,5,6], v => v > 0)) fails.push('all:predicate')\n  if (!_.all([0,0,0,0,0,0,0,0], 0)) fails.push('all:value')\n  if (_.all([1,0,0,0,0,0,0],0)) fails.push('all:value:negative')\n  if (_.all([0,1,2,3,4,5,6], v => v > 0)) fails.push('all:predicate:negative')\n\n  return fails\n}\n","import { _ } from './lfn'\n\nconst noop = () => {}\n\n/**\nA generic sequencer designed to allow for processor / memory heavy on a lighter load\nSequences should be as lazy as possible to defer massive allocations\nIf it helps at all, think about sequence like a promise with specific functionality for lists, and complexity\n*/\nexport class Sequence {\n    sequences = []\n    name = \"\"\n    result = undefined\n    thens = []\n\n    constructor(name) {\n        this.name = name\n    }\n\n    insertAt(sequence, data, index, cyclomaticComplexity) {\n        this.sequences.splice(index, 0, {\n            exec: sequence,\n            data: data,\n            cyclomaticComplexity: cyclomaticComplexity\n        }, index)\n    }\n\n    append(sequence, data, cyclomaticComplexity) {\n        this.sequences.push({\n            exec: sequence,\n            data: data,\n            cyclomaticComplexity: cyclomaticComplexity\n        })\n    }\n\n    add(sequence, data, cyclomaticComplexity) {\n      this.append(sequence, data, cyclomaticComplexity)\n    }\n\n    enqueue(sequence, data, cyclomaticComplexity) {\n        this.sequences.splice(0, 0, {\n            exec: sequence,\n            data: data,\n            cyclomaticComplexity: cyclomaticComplexity\n        })\n    }\n\n    /**\n     * Creates a sequence for each iteration of the loop\n     * @param {int} initial the initial value\n     * @param {function<bool>} predicate loop predicate\n     * @param {function<int>} incrementer the new value for the index\n     * @param {function<func or value>} sequence a function\n     * @param {value} data the value for the method\n     * @param {int} cyclomaticComplexity the cyclomatic complexity for each iteration\n\n     * @note this should be improved to handle variable range inputs - say you have to iterate through\n     *   many thousands of inputs, you could set max per iteration to 50, and it could use that to fill\n     *   the left over processing space, maybe pass it as a param to the exec function\n     */\n    iterate(initial, predicate, incrementer, sequenceFn, data, cyclomaticComplexity, useAdd = true) {\n        //we want to add a sequence that iterates over the sequence, pushing another iteration if !!predicate()\n        let index = initial;\n        // TODO: review: add and enqueue are kind of confusing, as queues are FIFO,\n        //               and [add]'ed sequences get FIFO, whereas enqueue is FILO\n        (useAdd ? this.add.bind(this) : this.enqueue.bind(this))(() => {\n            if (predicate(index)) {\n                sequenceFn()\n\n                index = incrementer(index)\n                this.iterate(index, predicate, incrementer, sequenceFn, data, cyclomaticComplexity, false)\n            }\n        }, data, cyclomaticComplexity)\n    }\n\n    resolve(value) {\n        //resolve with a value, ending exec of this sequence\n        this.result = value\n        this.sequences = []\n        if (this.thens?.length > 0) {\n          this.thens.forEach(then => then(this.result, null))\n        }\n        return this;\n    }\n\n    reject(error) {\n        this.sequences = []\n        if (this.thens?.length > 0) {\n          this.thens.forEach(then => then(undefined, error))\n        }\n        return this;\n    }\n\n    then(func = noop) {\n      return new Promise((resolve, reject) => {\n        this.thens.push((result, error) => {\n          if (error) {\n            reject(error)\n            return\n          }\n\n          resolve(func(result))\n        })\n      })\n    }\n\n    exec() {\n        if (this.sequences.length > 0) {\n            return this.sequences.shift().exec()\n        } else {\n            return undefined\n        }\n    }\n\n    execDesc() {\n      if (this.sequences.length > 0) {\n        return this.sequences.pop().exec()\n      } else {\n        return undefined\n      }\n    }\n\n    hasExec() {\n        return this.sequences.length > 0\n    }\n}\n\nconst MAX_COMPLEXITY = 37000\nexport class SequencePriorityQueue {\n    sequences = []\n\n    addSequence() {\n\n    }\n\n    completeSequence() {\n        return new Promise((resolve, reject) => {\n            //we can only handle ~37000 iterations per main loop exec\n            // what does that mean for the sequencer?\n            // uh, it means that we should pay attention to the cyclomatic complexity vs the data size\n            // our highest granularity data set will be heart rate / acc / gyrometer\n            // highest == 60 / minute .. 1 / second -> highest duration is 30 minutes -> 30 * 60 = 1800\n            // so perhaps we should take the length of the dataset * sequence.cyclomaticComplexity\n            // datasets that have no cyclomatic complexity or constant speed, should return 0\n            // this is a problem though, as 193 ^ 2 === 37249, so possibly we should be returning earlier,\n            // and the fitness functions will get super muddy with continuations and counters.\n            this.scheduleSequence(resolve)\n        })\n    }\n\n    scheduleSequence(resolve) {\n        this.sequenceIntervalId = setTimeout(() => {\n            this.getSequencesToExec().forEach(s => s.exec())\n\n            if (_.all(this.sequence, s => !s.hasExec())) {\n                clearTimeout(this.sequenceIntervalId)\n                resolve(this.sequences.reduce((m,c) => m[c.name] = c.result, {}))\n            } else {\n                this.scheduleSequence()\n            }\n        }, 1000)\n    }\n\n    getSequencesToExec() {\n        let sum = 0\n        return _.sortBy(sequences, s => s.cyclomaticComplexity).reduce((memo, curr) => {\n            //don't include this sequence if we already got a result, or if exec is null\n            if (curr.result !== undefined || curr.sequence === undefined) {\n                return memo\n            }\n\n            let currentComplexity = Math.pow(typeof curr.data === 'number' ? curr.data : curr.data.length, curr.cyclomaticComplexity)\n\n            if (currentComplexity > MAX_COMPLEXITY) {\n                throw new Error('MAX_COMPLEXITY exceeded by sequence ' + curr.name + ' with complexity count: ' + currentComplexity)\n            }\n\n            //otherwise just include it if adding it means we're under the max complixity\n            if (sum + currentComplexity <= MAX_COMPLEXITY) {\n                sum += currentComplexity\n                memo.push(curr)\n            }\n\n            return memo\n        }, [])\n    }\n}\n\n/**\n\nfunction complexFunction(sequencer, data) {\n    let someResult = null\n    sequencer.add(() => {\n        someResult = data.map(d => complexStuff(d))\n\n        sequencer.add(() => {\n            //if data is mutated or reliant on a lower scope\n            //nested sequencer.add is a good call\n            someResult = someResult.map(d => moreComplexStuff(d))\n        }, data, 2)\n    }, data, 2) //powers\n\n    //otherwise, procedural calls are fine\n    sequencer.add(() => {\n        let fitness = someResult.map(d => soMuchComplexityWowVeryMath(d)).reduce(fitnessssss)\n\n        return snakes(fitness).bunchOfSnakes(WHY_ALWAYS_SNAKES(\"?\"))\n    }, 3)\n\n    return sequencer\n}\n\nfunction schedulingExample() {\n    let sequencer = SequencePriorityQueue()\n    sequencer.addSequence(complexFunction(new Sequencer(\"complexFunction\"), slightlyConfusingMetricDataOrTraining))\n\n    sequencer.completeSequence().then(results => {\n        //probably change results set to include name or just make a map or add names\n        rejoiceAsItisSecondsLaterButWeveDoneCoolMath(results)\n    })\n}\n\n\n**/\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Patch environment detection for work-boots in Web Worker context\n// Work-boots expects window/document for browser detection, but workers only have 'self'\nif (typeof window === 'undefined' && typeof self !== 'undefined') {\n  // Make work-boots think we're in a browser by providing minimal window/document\n  globalThis.window = self;\n  globalThis.document = { }; // Minimal document object\n  console.log('Worker: Patched environment for work-boots browser detection');\n}\n\nconst workbootsExports = require('workboots');\nconsole.log('Worker: Available objects:');\nconsole.log('self.Socks:', self.Socks);\nconsole.log('self.WorkBoots:', self.WorkBoots);\nconsole.log('self.WorkBoots keys:', self.WorkBoots ? Object.keys(self.WorkBoots) : 'undefined');\n\n// Debug environment detection\nconsole.log('Worker environment detection:');\nconsole.log('typeof window:', typeof window);\nconsole.log('typeof document:', typeof document);\nconsole.log('typeof process:', typeof process);\nconsole.log('typeof self:', typeof self);\n\n// Try the nested structure like in main thread - use the same pattern as main thread\nconst Socks = self.WorkBoots && self.WorkBoots.Socks;\n\nconsole.log('Worker: About to create Socks instance');\nconsole.log('Worker: Socks constructor:', Socks);\nimport { Sequence } from './sequencer';\nimport { kmeans } from './k-means-clustering';\nimport tinycolor from 'tinycolor2';\n\n// Ensure Socks constructor is available before creating instance\nif (!Socks) {\n  console.error('Worker: Socks constructor not found! Available objects:', {\n    'self.Socks': self.Socks,\n    'self.WorkBoots': self.WorkBoots,\n    'workbootsExports': workbootsExports\n  });\n  throw new Error('Socks constructor not available');\n}\n\nconst socks = new Socks(self);\n\nconsole.log('Worker: Socks instance created:', socks);\n\n//todo: move this to the Socks class constructor, as a warning for missing socks.ready() call\n// easy to do, even if this is cheesy\n// Add timeout warning for missing socks.ready() call\nlet readyCalled = false;\nsetTimeout(() => {\n  if (!readyCalled) {\n    console.warn('WARNING: socks.ready() was not called within 3000ms! This may cause communication issues.');\n  }\n}, 3000);\n\nsocks.onMessage(({ data }) => {\n  if ('imageData' in data) {\n    startClustering(data);\n  }\n});\n\nconst PROGRESS_UPDATE_STEP = 10;\nlet progressCounter = 0;\n\n// Progressive quad-based downsampling with centroid convergence testing and streaming\nconst startClustering = async ({ imageData, iterations = 10, palletSize = 10, width, height, hsvTolerance = 30, toleranceEnabled = true, distanceMethod = 'hsv-max' }) => {\n  progressCounter = 0;\n  \n  console.log(`Starting progressive clustering: ${width}x${height} image, ${palletSize} colors, ${iterations} max iterations`);\n  \n  // Define resolution levels: [quadSize, description, maxIterations]\n  // Mobile devices get fewer iterations for faster processing and limited quad sizes\n  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n  const mobileIterations = Math.max(2, Math.floor(iterations / 2)); // Half iterations for mobile\n  \n  // Mobile devices skip fine-grained processing (min 4x4 quads) for better performance\n  const resolutionLevels = isMobile ? [\n    [8, '8x8 quads', mobileIterations],\n    [6, '6x6 quads', mobileIterations],\n    [4, '4x4 quads', mobileIterations]\n  ] : [\n    [8, '8x8 quads', iterations],\n    [6, '6x6 quads', iterations],\n    [4, '4x4 quads', iterations],\n    [2, '2x2 quads', iterations],\n    [1, '1x1 pixels', iterations]\n  ];\n  \n  let currentCentroids = null;\n  let previousCentroids = null;\n  // Mobile devices get a higher convergence threshold for faster processing\n  let convergenceThreshold = isMobile ? 0.03 : 0.01; // Higher threshold for mobile\n  \n  // Send initial progress\n  socks.postMessage({ \n    progressUpdate: 0,\n    status: 'Starting progressive clustering...'\n  });\n  \n  // Add streaming delay function for mobile devices\n  const streamingDelay = (customDelay = null) => {\n    if (isMobile) {\n      const delay = customDelay || 50; // Default 50ms, but can be customized\n      return new Promise(resolve => setTimeout(resolve, delay));\n    }\n    return Promise.resolve();\n  };\n  \n  // Log mobile-specific optimizations\n  if (isMobile) {\n    console.log('📱 Mobile device detected - using optimized settings:');\n    console.log(`   - Min quad size: 4x4 (skipping 2x2 and 1x1 for performance)`);\n    console.log(`   - Max iterations: ${mobileIterations} (vs ${iterations} on desktop)`);\n    console.log(`   - Resolution levels: ${resolutionLevels.length} (vs 5 on desktop)`);\n  }\n  \n  // Process each resolution level with streaming\n  for (const [quadSize, description, maxIterations] of resolutionLevels) {\n    console.log(`Processing at ${description} resolution with max ${maxIterations} iterations...`);\n    \n    // Send progress update for current resolution\n    socks.postMessage({ \n      progressUpdate: Math.round((resolutionLevels.findIndex(([size]) => size === quadSize) / resolutionLevels.length) * 20),\n      status: `Processing ${description} resolution...`\n    });\n    \n    // Add streaming delay for mobile\n    await streamingDelay();\n    \n    // Downsample image data to current resolution\n    const { downsampledData, downsampledWidth, downsampledHeight } = downsampleImage(imageData, width, height, quadSize);\n   \n    console.log(`Downsampled to ${downsampledWidth}x${downsampledHeight} (${downsampledData.length / 4} pixels)`);\n    \n    // Convert to HSV arrays with streaming\n    const hsvArray = [];\n    const colors = [];\n    // Mobile devices get smaller chunks for better responsiveness\n    const chunkSize = isMobile ? 500 : 5000; // Smaller chunks for mobile\n    \n    for (let i = 0; i < downsampledData.length; i += 4) {\n      const rgba = tinycolor({\n        r: downsampledData[i + 0],\n        g: downsampledData[i + 1],\n        b: downsampledData[i + 2],\n        a: downsampledData[i + 3]\n      });\n\n      const { h, s, v } = rgba.toHsv();\n      hsvArray.push([h, s, v]);\n      colors.push({\n        x: (i / 4) % downsampledWidth,\n        y: Math.floor(i / 4 / downsampledWidth),\n        color: rgba.toHexString(),\n        hsv: [h, s, v]\n      });\n      \n      // Streaming yield point for mobile devices\n      if (isMobile && (i / 4) % chunkSize === 0) {\n        await streamingDelay();\n      }\n    }\n    \n    // Run k-means clustering at current resolution\n    const sequence = new Sequence();\n    \n    try {\n      // For now, use direct fallback approach until we fix the sequencer issue\n      console.log(`Using direct k-means fallback for ${hsvArray.length} pixels, ${palletSize} colors`);\n      const centroids = createAdvancedCentroids(hsvArray, palletSize);\n      const points = []; // We don't need points for the current use case\n      \n      console.log(`Clustering at ${description} completed:`, { \n        centroidsCount: centroids?.length || 0, \n        pointsCount: points?.length || 0\n      });\n     \n      // Check for centroid convergence\n      if (previousCentroids && currentCentroids) {\n        const convergenceScore = calculateCentroidConvergence(previousCentroids, centroids);\n        console.log(`Convergence score at ${description}: ${convergenceScore.toFixed(4)} (threshold: ${convergenceThreshold})`);\n        \n        if (convergenceScore < convergenceThreshold) {\n          console.log(`✅ Centroids converged at ${description} resolution! Stopping early.`);\n          currentCentroids = centroids;\n          break;\n        }\n      }\n      \n      // Store centroids for next iteration\n      previousCentroids = currentCentroids;\n      currentCentroids = centroids;\n      \n      // Update progress with detailed information\n      const levelIndex = resolutionLevels.findIndex(([size]) => size === quadSize);\n      const progress = Math.round(((levelIndex + 1) / resolutionLevels.length) * 80); // 80% for resolution processing\n      socks.postMessage({ \n        progressUpdate: progress,\n        status: `Completed ${description} (${downsampledWidth}x${downsampledHeight} pixels)`\n      });\n     \n    } catch (error) {\n      console.error(`Error clustering at ${description} resolution:`, error);\n      // Continue to next resolution level\n      continue;\n    }\n  }\n  \n  // Process final results\n   if (currentCentroids) {\n     console.log('Processing final clustering results...');\n     \n     // Send final progress update\n     socks.postMessage({ \n       progressUpdate: 100,\n       status: `Clustering complete! Found ${currentCentroids.length} colors`\n     });\n     \n     // Send progress update for final processing\n     socks.postMessage({ \n       progressUpdate: 85,\n       status: 'Generating final color data...'\n     });\n     \n     // Regenerate colors at full resolution for final processing with streaming\n     const fullResolutionColors = [];\n     // Mobile devices get much smaller chunks for better responsiveness during final processing\n     const finalChunkSize = isMobile ? 500 : 10000; // Much smaller chunks for mobile\n     \n     console.log(`📱 Mobile: Processing ${imageData.length / 4} pixels with chunk size ${finalChunkSize}`);\n     \n     for (let i = 0; i < imageData.length; i += 4) {\n       const rgba = tinycolor({\n         r: imageData[i + 0],\n         g: imageData[i + 1],\n         b: imageData[i + 2],\n         a: imageData[i + 3]\n       });\n\n       const { h, s, v } = rgba.toHsv();\n       fullResolutionColors.push({\n         x: (i / 4) % width,\n         y: Math.floor(i / 4 / width),\n         color: rgba.toHexString(),\n         hsv: [h, s, v]\n       });\n       \n               // Streaming yield point for mobile devices - much more frequent with shorter delays\n        if (isMobile && (i / 4) % finalChunkSize === 0) {\n          await streamingDelay(25); // Shorter delay for final processing\n          \n          // Send incremental progress updates for mobile\n          const progress = 85 + Math.round((i / imageData.length) * 10);\n          socks.postMessage({ \n            progressUpdate: progress,\n            status: `Mobile: Processing pixels ${Math.round((i / imageData.length) * 100)}%`\n          });\n        }\n     }\n     \n     // Send final progress update\n     socks.postMessage({ \n       progressUpdate: 95,\n       status: 'Finalizing clustering results...'\n     });\n     \n     // Add final streaming delay for mobile\n     await streamingDelay();\n     \n     finished({ \n       centroids: currentCentroids, \n       imageData, \n       colors: fullResolutionColors, // Full resolution colors for example finding\n       hsvTolerance, \n       toleranceEnabled, \n       width, \n       height, \n       palletSize, \n       iterations, \n       distanceMethod \n     });\n   } else {\n     console.error('No centroids generated from clustering');\n     socks.postMessage({ error: 'Clustering failed to generate centroids' });\n   }\n};\n\n// Downsample image data by averaging pixels in quad regions\nconst downsampleImage = (imageData, width, height, quadSize) => {\n  const downsampledWidth = Math.ceil(width / quadSize);\n  const downsampledHeight = Math.ceil(height / quadSize);\n  const downsampledData = new Uint8ClampedArray(downsampledWidth * downsampledHeight * 4);\n  \n  for (let dy = 0; dy < downsampledHeight; dy++) {\n    for (let dx = 0; dx < downsampledWidth; dx++) {\n      const sx = dx * quadSize;\n      const sy = dy * quadSize;\n      \n      let r = 0, g = 0, b = 0, a = 0;\n      let pixelCount = 0;\n      \n      // Average pixels in the quad region\n      for (let qy = 0; qy < quadSize && sy + qy < height; qy++) {\n        for (let qx = 0; qx < quadSize && sx + qx < width; qx++) {\n          const sourceIndex = ((sy + qy) * width + (sx + qx)) * 4;\n          r += imageData[sourceIndex];\n          g += imageData[sourceIndex + 1];\n          b += imageData[sourceIndex + 2];\n          a += imageData[sourceIndex + 3];\n          pixelCount++;\n        }\n      }\n      \n      // Calculate average and store in downsampled data\n      const destIndex = (dy * downsampledWidth + dx) * 4;\n      downsampledData[destIndex] = Math.round(r / pixelCount);\n      downsampledData[destIndex + 1] = Math.round(g / pixelCount);\n      downsampledData[destIndex + 2] = Math.round(b / pixelCount);\n      downsampledData[destIndex + 3] = Math.round(a / pixelCount);\n    }\n  }\n  \n  return { downsampledData, downsampledWidth, downsampledHeight };\n};\n\n// Create fallback centroids if k-means fails\nconst createFallbackCentroids = (hsvArray, k) => {\n  console.log(`Creating fallback centroids for ${k} colors from ${hsvArray.length} data points`);\n  \n  // Simple approach: sample evenly distributed colors from the data\n  const step = Math.max(1, Math.floor(hsvArray.length / k));\n  const centroids = [];\n  \n  for (let i = 0; i < k && i * step < hsvArray.length; i++) {\n    const index = i * step;\n    const hsv = hsvArray[index];\n    \n    // Create a mock centroid object with the expected interface\n    const centroid = {\n      location: () => hsv,\n      label: () => i\n    };\n    \n    centroids.push(centroid);\n  }\n  \n  console.log(`Created ${centroids.length} fallback centroids`);\n  return centroids;\n};\n\n// Create advanced centroids using a simplified k-means approach\nconst createAdvancedCentroids = (hsvArray, k) => {\n  console.log(`Creating advanced centroids for ${k} colors from ${hsvArray.length} data points`);\n  \n  if (hsvArray.length === 0) {\n    return [];\n  }\n  \n  // Initialize centroids with evenly distributed samples\n  const step = Math.max(1, Math.floor(hsvArray.length / k));\n  let centroids = [];\n  \n  for (let i = 0; i < k && i * step < hsvArray.length; i++) {\n    const index = i * step;\n    centroids.push([...hsvArray[index]]); // Copy HSV values\n  }\n  \n  // If we don't have enough centroids, fill with random samples\n  while (centroids.length < k && hsvArray.length > 0) {\n    const randomIndex = Math.floor(Math.random() * hsvArray.length);\n    centroids.push([...hsvArray[randomIndex]]);\n  }\n  \n  // Perform a few iterations of k-means\n  const maxIterations = 3;\n  for (let iter = 0; iter < maxIterations; iter++) {\n    // Assign points to nearest centroids\n    const clusters = Array(k).fill().map(() => []);\n    \n    for (const point of hsvArray) {\n      let nearestCentroid = 0;\n      let minDistance = Infinity;\n      \n      for (let c = 0; c < centroids.length; c++) {\n        const distance = hsvDistance(point, centroids[c]);\n        if (distance < minDistance) {\n          minDistance = distance;\n          nearestCentroid = c;\n        }\n      }\n      \n      clusters[nearestCentroid].push(point);\n    }\n    \n    // Update centroids to cluster means\n    for (let c = 0; c < centroids.length; c++) {\n      if (clusters[c].length > 0) {\n        const sumH = clusters[c].reduce((sum, p) => sum + p[0], 0);\n        const sumS = clusters[c].reduce((sum, p) => sum + p[1], 0);\n        const sumV = clusters[c].reduce((sum, p) => sum + p[2], 0);\n        \n        centroids[c] = [\n          sumH / clusters[c].length,\n          sumS / clusters[c].length,\n          sumV / clusters[c].length\n        ];\n      }\n    }\n  }\n  \n  // Convert to expected centroid object format\n  const result = centroids.map((hsv, index) => ({\n    location: () => hsv,\n    label: () => index\n  }));\n  \n  console.log(`Created ${result.length} advanced centroids`);\n  return result;\n};\n\n// Calculate convergence between two sets of centroids\nconst calculateCentroidConvergence = (centroids1, centroids2) => {\n  console.log('Calculating convergence between:', { \n    centroids1: centroids1?.length || 0, \n    centroids2: centroids2?.length || 0 \n  });\n  \n  if (!centroids1 || !centroids2 || centroids1.length !== centroids2.length) {\n    console.log('Convergence check failed - centroids mismatch');\n    return Infinity; // No convergence if centroids don't match\n  }\n  \n  let totalDistance = 0;\n  \n  for (let i = 0; i < centroids1.length; i++) {\n    const loc1 = centroids1[i].location();\n    const loc2 = centroids2[i].location();\n    \n    console.log(`Centroid ${i}:`, { loc1, loc2 });\n    \n    // Calculate Euclidean distance in HSV space\n    const hDiff = Math.abs(loc1[0] - loc2[0]) / 360; // Normalize hue difference\n    const sDiff = Math.abs(loc1[1] - loc2[1]);\n    const vDiff = Math.abs(loc1[2] - loc2[2]);\n    \n    const distance = Math.sqrt(hDiff * hDiff + sDiff * sDiff + vDiff * vDiff);\n    totalDistance += distance;\n  }\n  \n  const avgDistance = totalDistance / centroids1.length;\n  console.log(`Convergence calculation: totalDistance=${totalDistance}, avgDistance=${avgDistance}`);\n  return avgDistance; // Average distance\n};\n\nconst progressUpdate = () => {\n  progressCounter++;\n  const percentage = Math.min(progressCounter * 2, 99); // Rough progress estimation\n  socks.postMessage({ progressUpdate: percentage });\n}\n\nconst v3distance = (v1, v2) => {\n  const x = v1[0] - v2[0];\n  const y = v1[1] - v2[1];\n  const z = v1[2] - v2[2];\n  return Math.pow(x*x + y*y + z*z, 0.5)\n}\n\nconst finished = ({ centroids, imageData, colors, hsvTolerance = 30, toleranceEnabled = true, width, height, palletSize = 20, iterations = 10, distanceMethod = 'hsv-max' }) => {\n  // Convert HSV tolerance from degrees to normalized distance (0-1)\n  const normalizedTolerance = hsvTolerance / 360;\n  \n  let selectedCentroids = [];\n  \n    if (toleranceEnabled) {\n    // First pass: try to find colors that meet the tolerance requirement\n    const allCentroids = centroids.map(c => c.location());\n    const acceptedColors = [];\n    \n    console.log(`HSV Tolerance: ${hsvTolerance}° (${(normalizedTolerance * 100).toFixed(1)}% normalized)`);\n    console.log(`Distance Method: ${distanceMethod}`);\n    console.log(`Total centroids found: ${allCentroids.length}`);\n    console.log(`Iterations used: ${iterations}`);\n    \n    // Temporary debug: If tolerance is too strict, let's see what happens without it\n    if (selectedCentroids.length === 0 && toleranceEnabled) {\n      console.log(`⚠️  WARNING: No colors passed tolerance filter! Trying without tolerance...`);\n      selectedCentroids = allCentroids.slice(0, Math.min(allCentroids.length, palletSize));\n      console.log(`📊 Using all ${selectedCentroids.length} centroids without tolerance filtering`);\n    }\n    \n    // Debug: Log all centroids to see if they're converging to similar values\n    allCentroids.forEach((centroid, index) => {\n      const [h, s, v] = centroid;\n      console.log(`Centroid ${index}: HSV(${h.toFixed(1)}, ${(s * 100).toFixed(1)}%, ${(v * 100).toFixed(1)}%)`);\n    });\n    \n    // Sort centroids by quality metric (saturation + value, preferring more vibrant colors)\n    const sortedCentroids = allCentroids.map((centroid, index) => ({\n      centroid,\n      index,\n      // Quality metric: weighted combination of saturation and value\n      // Higher saturation and moderate value = more interesting colors\n      quality: (centroid[1] * 0.7) + (centroid[2] * 0.3) // 70% saturation, 30% value\n    })).sort((a, b) => b.quality - a.quality);\n    \n    // First pass: only accept colors that meet tolerance requirements\n    for (const { centroid } of sortedCentroids) {\n      const [h1, s1, v1] = centroid;\n      let meetsTolerance = true;\n      \n      // Check if this color is far enough from all accepted colors\n      for (const acceptedColor of acceptedColors) {\n        const distance = calculateColorDistance([h1, s1, v1], acceptedColor, distanceMethod);\n        console.log(`  Comparing to accepted color HSV(${acceptedColor[0].toFixed(1)}, ${(acceptedColor[1] * 100).toFixed(1)}%, ${(acceptedColor[2] * 100).toFixed(1)}%): distance=${distance.toFixed(4)}, tolerance=${normalizedTolerance.toFixed(4)}`);\n        if (distance < normalizedTolerance) {\n          console.log(`  ❌ REJECTED: Too close to accepted color`);\n          meetsTolerance = false;\n          break;\n        }\n      }\n      \n      if (meetsTolerance) {\n        acceptedColors.push([h1, s1, v1]);\n        selectedCentroids.push(centroid);\n        console.log(`  ✅ ACCEPTED: HSV(${h1.toFixed(1)}, ${(s1 * 100).toFixed(1)}%, ${(v1 * 100).toFixed(1)}%)`);\n      } else {\n        console.log(`  ❌ REJECTED: HSV(${h1.toFixed(1)}, ${(s1 * 100).toFixed(1)}%, ${(v1 * 100).toFixed(1)}%)`);\n      }\n    }\n    \n    console.log(`First pass: ${selectedCentroids.length} colors accepted out of ${allCentroids.length} total`);\n    \n    // If we don't have enough colors, do a second pass with fallback strategy\n    if (selectedCentroids.length < allCentroids.length) {\n      console.log(`Need more colors. Starting fallback strategy...`);\n      \n      const remainingCentroids = sortedCentroids.filter(({ centroid }) => {\n        return !selectedCentroids.some(selected => \n          calculateColorDistance(centroid, selected, distanceMethod) < normalizedTolerance\n        );\n      });\n      \n      console.log(`Remaining centroids for fallback: ${remainingCentroids.length}`);\n      \n      // Sort remaining colors by distance from the mean of accepted colors\n      if (acceptedColors.length > 0) {\n        const meanH = acceptedColors.reduce((sum, [h]) => sum + h, 0) / acceptedColors.length;\n        const meanS = acceptedColors.reduce((sum, [, s]) => sum + s, 0) / acceptedColors.length;\n        const meanV = acceptedColors.reduce((sum, [, , v]) => sum + v, 0) / acceptedColors.length;\n        const meanColor = [meanH, meanS, meanV];\n        \n        remainingCentroids.sort((a, b) => {\n          const distanceA = calculateColorDistance(a.centroid, meanColor, distanceMethod);\n          const distanceB = calculateColorDistance(b.centroid, meanColor, distanceMethod);\n          return distanceB - distanceA; // Sort by distance from mean (farthest first)\n        });\n      }\n      \n      // Add remaining colors until we reach the target palette size or run out\n      const targetSize = Math.min(allCentroids.length, palletSize);\n      console.log(`Target palette size: ${targetSize}`);\n      \n      for (const { centroid } of remainingCentroids) {\n        if (selectedCentroids.length >= targetSize) break;\n        const [h, s, v] = centroid;\n        selectedCentroids.push(centroid);\n        console.log(`Fallback accepted: HSV(${h.toFixed(1)}, ${(s * 100).toFixed(1)}%, ${(v * 100).toFixed(1)}%)`);\n      }\n    }\n    \n    console.log(`Final palette: ${selectedCentroids.length} colors selected`);\n  } else {\n    // If tolerance is disabled, use all centroids\n    selectedCentroids = centroids.map(c => c.location());\n  }\n\n  const graphNodes = selectedCentroids\n    .map(c => {\n      const [h,s,v] = c;\n      const centroidHSV = [h,s,v];\n      const color = tinycolor({ h,s,v }).toHexString();\n      \n      // Find the largest connected area for this color\n      const example = findLargestColorArea(colors, centroidHSV, width, height, distanceMethod);\n      \n      if (!example) {\n        console.log(`unable to find color example for color: ${color}`);\n        return undefined;\n      }\n      return {\n        x: example.x,\n        y: example.y,\n        color: color\n      };\n    })\n    .filter(c => !!c);\n\n  socks.postMessage({ graphNodes });\n}\n\n// Helper function to convert HSV to 3D vector for angle calculations\nconst hsvToVector = (h, s, v) => {\n  // Convert HSV to 3D vector representation\n  // H: angle around the circle (0-360)\n  // S: radius from center (0-1)\n  // V: height (0-1)\n  const hRadians = (h * Math.PI) / 180;\n  const x = s * Math.cos(hRadians);\n  const y = s * Math.sin(hRadians);\n  const z = v;\n  return [x, y, z];\n}\n\n// HSV distance calculation using weighted components\nconst hsvDistance = (hsv1, hsv2) => {\n  const [h1, s1, v1] = hsv1;\n  const [h2, s2, v2] = hsv2;\n  \n  // Handle hue wrapping (0 and 360 are the same)\n  let hDiff = Math.abs(h1 - h2);\n  if (hDiff > 180) {\n    hDiff = 360 - hDiff;\n  }\n  \n  // Weighted distance calculation\n  const hWeight = 1.0;\n  const sWeight = 1.0;\n  const vWeight = 1.0;\n  \n  const hDist = (hDiff / 180) * hWeight;\n  const sDist = Math.abs(s1 - s2) * sWeight;\n  const vDist = Math.abs(v1 - v2) * vWeight;\n  \n  return Math.sqrt(hDist * hDist + sDist * sDist + vDist * vDist);\n}\n\n// HSL distance calculation using weighted components\nconst hslDistance = (hsl1, hsl2) => {\n  const [h1, s1, l1] = hsl1;\n  const [h2, s2, l2] = hsl2;\n  \n  // Handle hue wrapping (0 and 360 are the same)\n  let hDiff = Math.abs(h1 - h2);\n  if (hDiff > 180) {\n    hDiff = 360 - hDiff;\n  }\n  \n  // Weighted distance calculation\n  const hWeight = 1.0;\n  const sWeight = 1.0;\n  const lWeight = 1.0;\n  \n  const hDist = (hDiff / 180) * hWeight;\n  const sDist = Math.abs(s1 - s2) * sWeight;\n  const lDist = Math.abs(l1 - l2) * lWeight;\n  \n  return Math.sqrt(hDist * hDist + sDist * sDist + lDist * lDist);\n}\n\n// Universal distance calculation function that handles all methods\nconst calculateColorDistance = (color1, color2, method) => {\n  switch (method) {\n    case 'hsv-max':\n      return hsvDistance(color1, color2);\n    case 'hsv-avg':\n      return hsvDistance(color1, color2);\n    case 'hsl-max':\n      // Convert HSV to HSL for comparison\n      const color1HSL = tinycolor({ h: color1[0], s: color1[1], v: color1[2] }).toHsl();\n      const color2HSL = tinycolor({ h: color2[0], s: color2[1], v: color2[2] }).toHsl();\n      return hslDistance([color1HSL.h, color1HSL.s, color1HSL.l], [color2HSL.h, color2HSL.s, color2HSL.l]);\n    case 'hsl-avg':\n      // Convert HSV to HSL for comparison\n      const color1HSL_avg = tinycolor({ h: color1[0], s: color1[1], v: color1[2] }).toHsl();\n      const color2HSL_avg = tinycolor({ h: color2[0], s: color2[1], v: color2[2] }).toHsl();\n      return hslDistance([color1HSL_avg.h, color1HSL_avg.s, color1HSL_avg.l], [color2HSL_avg.h, color2HSL_avg.s, color2HSL_avg.l]);\n    case 'max-hsv-hsl':\n      // Calculate both HSV and HSL distances, return the maximum\n      const hsvDist = hsvDistance(color1, color2);\n      const color1HSL_max = tinycolor({ h: color1[0], s: color1[1], v: color1[2] }).toHsl();\n      const color2HSL_max = tinycolor({ h: color2[0], s: color2[1], v: color2[2] }).toHsl();\n      const hslDist = hslDistance([color1HSL_max.h, color1HSL_max.s, color1HSL_max.l], [color2HSL_max.h, color2HSL_max.s, color2HSL_max.l]);\n      const maxDist = Math.max(hsvDist, hslDist);\n      console.log(`    Max(HSV, HSL): HSV=${hsvDist.toFixed(4)}, HSL=${hsvDist.toFixed(4)}, Max=${maxDist.toFixed(4)}`);\n      return maxDist;\n    default:\n      return hsvDistance(color1, color2);\n  }\n}\n\n// Helper function to find the largest connected area for a color\nconst findLargestColorArea = (colors, targetHSV, width, height, distanceMethod = 'hsv-max') => {\n  const tolerance = 0.15; // Color similarity tolerance\n  const visited = new Set();\n  let largestArea = null;\n  let maxArea = 0;\n  \n  for (let i = 0; i < colors.length; i++) {\n    if (visited.has(i)) continue;\n    \n    const color = colors[i];\n    const distance = calculateColorDistance(targetHSV, color.hsv, distanceMethod);\n    \n    if (distance <= tolerance) {\n      // Found a matching color, flood fill to find connected area\n      const area = floodFill(colors, i, targetHSV, tolerance, width, height, visited, distanceMethod);\n      \n      if (area.pixels.length > maxArea) {\n        maxArea = area.pixels.length;\n        largestArea = area;\n      }\n    }\n  }\n  \n  return largestArea ? largestArea.centroid : null;\n}\n\n// Flood fill algorithm to find connected areas\nconst floodFill = (colors, startIndex, targetHSV, tolerance, width, height, visited, distanceMethod = 'hsv-max') => {\n  const stack = [startIndex];\n  const pixels = [];\n  let sumX = 0, sumY = 0;\n  \n  while (stack.length > 0) {\n    const index = stack.pop();\n    if (visited.has(index)) continue;\n    \n    visited.add(index);\n    const color = colors[index];\n    const distance = calculateColorDistance(targetHSV, color.hsv, distanceMethod);\n    \n    if (distance <= tolerance) {\n      pixels.push(color);\n      sumX += color.x;\n      sumY += color.y;\n      \n      // Add neighboring pixels (4-connected for better performance)\n      const x = color.x;\n      const y = color.y;\n      \n      // Check 4-connected neighbors (faster than 8-connected)\n      const neighbors = [\n        [x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]\n      ];\n      \n      for (const [nx, ny] of neighbors) {\n        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\n          const neighborIndex = ny * width + nx;\n          if (!visited.has(neighborIndex)) {\n            stack.push(neighborIndex);\n          }\n        }\n      }\n    }\n  }\n  \n  return {\n    pixels,\n    centroid: pixels.length > 0 ? {\n      x: Math.round(sumX / pixels.length),\n      y: Math.round(sumY / pixels.length)\n    } : null\n  };\n}\n\nsocks.ready();\nreadyCalled = true;\n\nexport {\n  socks\n};\n"],"sourceRoot":""}